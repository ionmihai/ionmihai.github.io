{"title":"L10: Merging, reshaping datasets","markdown":{"yaml":{"title":"L10: Merging, reshaping datasets"},"headingText":"Preliminaries","containsRefs":false,"markdown":"\n\n\nThe data we need for our projects is rarely all in one place (in a single dataframe) or organized the way we need it. This means that we very often have to combine two or more datasets into a single dataset and/or change the organization of the dataset (what appears in the rows and what appears in the columns) to better suit our needs. Here we cover some of the main tools we can use to perform these operations using the Pandas package.\n\nLet's create some example datasets:\n\n# Merging datasets\n\nWhen we say we want to \"merge\" two datasets, we generally mean that we want the columns of the two datasets to appear side by side in one final dataset. The important question is: How should the ROWS of the two datasets be matched? To perform this match, we need to have one or more columns that contain the same information in each of the two datasets. These common columns are usually referred to as the \"keys\" on which the rows are matched. \n\nThe second thing we have to decide is what to do with the rows that do NOT match after the merge. This is where we have to decide if we want an \"inner\", \"outer\", \"left\", or \"right\" merge (aka join), as specified below.\n\nMost commonly, we use the ``.merge()`` function when the keys on which we want to merge the datasets are columns, and the ``.join()`` function when they are indexes (even though ``.merge()`` can also merge on index). We cover these two functions separately in the two subsections below:\n\n## Merging by columns with ``.merge()``\n\nIf the keys we want to merge on are columns in our dataframes (as opposed to indexes) we have to use the ``.merge()`` (``.join()`` will not work for this purpose):\n\nAbbreviated syntax:\n```python\nDataFrame.merge(right, how='inner', on=None, \n                left_on=None, right_on=None, \n                left_index=False, right_index=False, \n                sort=False, suffixes=('_x', '_y'))\n```\n\nWe'll replace ``DataFrame`` and ``right`` with the names of the two dataframes we want to merge (respectively). In the subsections below, we explain what the different choices for ``how`` mean. When the key(s) on which we want to merge have the same name(s) in the two datasets, we use the ``on`` parameter to specify the names of the keys (see the example immediately below), otherwise we need to specify them using the ``left_on`` and ``right_on`` parameters.\n\nThe documentation at https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html has some additional examples that you may find useful.\n\n### Inner join\n\nThe inner join combines the datasets based on the INTERSECTION of the values in the \"key\" columns.\n\nFor example, if we want to inner merge the two dataframes using the ``year`` column as a key:\n\nBut if we want to merge on both ``year`` and ticker information, we can not use ``on`` because the ticker information has different names in the different dataframes:\n\nNote how the name of the ``fy`` column in each of the two datasets has been changed. To control that process ourselves, we can use the ``suffixes`` parameter to specify suffixes that should be appended at the end of common column names:\n\n### Outer join\n\nThe outer join combines the datasets based on the UNION of the values in the \"key\" columns. For example:\n\n### Left join\n\nIn a left join, the unmatched keys from the left dataset are kept, but the unmatched keys from the right dataset are discarded.\n\n### Right join\n\nIn a right join, the unmatched keys from the right dataset are kept, but the unmatched keys from the left dataset are discarded.\n\n## Merging on index using ``.join()`` (and ``.merge()``)\n\nAs mentioned above, this covers the situation when the keys on which we want to perform the merge are indexes in the dataframes we want to merge. In this case, we can either use the ``.merge()`` function and specify ``left_index=True, right_index=True``, or we can use the ``.join()`` funciton without specifying any keys at all (because ``.join()`` assumes that you are using the index):\n\nFirst, let's add an index (MultiIndex) to the two dataframes: \n\nBefore we can use ``.merge()``, we have to make the index names match (``tic`` does not match ``ticker``):\n\nNow, say we want to perform an outer merge on the index:\n\nUsing the ``.join()`` function will not work unless we specify how the ``fy`` columns need to be renamed. We use the ``lsuffix`` and ``rsuffix`` parameters for this purpose.\n\nSyntax:\n```python\nDataFrame.join(other, on=None, how='left', lsuffix='', rsuffix='', sort=False)\n```\n\nFor example, we can perform the same outer merge as above using:\n\n# Concatenating  datasets with ``.concat()``\n\nWhen we say that we want to \"concatenate\" two datasets, we generally mean that we want the columns of the two datasets to be stacked on top of each other (vertically) or side by side (horizontally). We usually want to concatenate vertically (aka \"appending\") when we obtain more data on a given set of variables, and we just want to add it at the bottom of a dataset already containing those variables (columns).\n\nUnlike merging, concatenating horizontally means that we want to combine two datasets side by side, but \"as they are\", without concern for matching rows in any meaningful way (like merge). This is usually done when we want to combine different pieces of information (columns) from the two datasets, and we are certain that existing datasets are already organized in such a way that the rows will match meaningfully.\n\nThe ``.concat()`` function can perform both types of concatenation (it can also perform a merge but we will not use it for that purpose in this course):\n\nSyntax:\n```python\npandas.concat(objs, axis=0, join='outer', ignore_index=False, keys=None, levels=None, names=None, sort=False, copy=True)\n```\n\nWe specify ``axis=0`` for vertical concatenation and ``axis=1`` for horizontal concatenation:\n\nNote that, ``.concat()`` with ``axis=1`` is equivalent to ``.join()`` with ``how='outer'``. In other words, ``.concat()`` performs a merge on index. Its default ``join`` argument is set to ``outer`` but you can change that to perform any kind of join you want.\n\n# Reshaping datasets\n\nBy reshaping a dataset we generally mean that we want to change the structure of the dataset so that either\n\n1. Some data stored in one column is converted to multiple columns (but the same row)\n    - In pandas, this is called \"unstacking\"\n    - Informally, we say that we are converting the dataset from long to wide\n    \nor\n\n2. Some data stored in multiple columns (but the same row) is converted to a single column\n    - In pandas, this is called \"stacking\"\n    - Informally, we say that we are converting the dataset from wide to long\n      \nSee the official user guide page for more details on reshaping: https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html \n\n## From long to wide (unstacking) with ``.pivot()``\n\nSyntax:\n```python\nDataFrame.pivot(index=None, columns=None, values=None)\n```\n\nLet's create an example dataset:\n\nFor example, if we want to reshape the ``return`` data so that each ``year`` gets its own row (index value), and each ``portfolio`` gets its own column, we would use:\n\nIf we want to reshape both the ``return`` data and the ``nfirms`` data in the same way, at the same time:\n\nNote that now the column labels are two-dimensional:\n\nUnstacking based on values in the index can be done using the ``.unstack()`` function (usually for datasets with a MultiIndex).\n\n## From wide to long (stacking) with ``.stack()``\n\nWe can stack the data back up to a \"long\" shape, based on information in the index of that dataframe.\n\nSyntax:\n```python\nDataFrame.stack(level=-1, dropna=True)\n```\n\nThe ``level`` parameter is used in case the dataframe we want to reshape has a MultiIndex in the columns i.e. multi-dimensional column names (like ``wide2`` above). The default ``level=-1`` works for dataframes that were reshaped from a different dataframe (like ``wide2`` above). In that case ``level=-1`` tells Python to just undo that reshaping:\n\nIf we want to stack the information in the first dimension of the column MultiIndex (i.e. the part that contains \"return\" and \"nfirms\"), then we use ``level=0``:\n\nIf we want to stack the information in the second dimension of the column MultiIndex (i.e. the part that contains 1's and 2's), then we use ``level=1``:\n","srcMarkdownNoYaml":"\n\n# Preliminaries\n\nThe data we need for our projects is rarely all in one place (in a single dataframe) or organized the way we need it. This means that we very often have to combine two or more datasets into a single dataset and/or change the organization of the dataset (what appears in the rows and what appears in the columns) to better suit our needs. Here we cover some of the main tools we can use to perform these operations using the Pandas package.\n\nLet's create some example datasets:\n\n# Merging datasets\n\nWhen we say we want to \"merge\" two datasets, we generally mean that we want the columns of the two datasets to appear side by side in one final dataset. The important question is: How should the ROWS of the two datasets be matched? To perform this match, we need to have one or more columns that contain the same information in each of the two datasets. These common columns are usually referred to as the \"keys\" on which the rows are matched. \n\nThe second thing we have to decide is what to do with the rows that do NOT match after the merge. This is where we have to decide if we want an \"inner\", \"outer\", \"left\", or \"right\" merge (aka join), as specified below.\n\nMost commonly, we use the ``.merge()`` function when the keys on which we want to merge the datasets are columns, and the ``.join()`` function when they are indexes (even though ``.merge()`` can also merge on index). We cover these two functions separately in the two subsections below:\n\n## Merging by columns with ``.merge()``\n\nIf the keys we want to merge on are columns in our dataframes (as opposed to indexes) we have to use the ``.merge()`` (``.join()`` will not work for this purpose):\n\nAbbreviated syntax:\n```python\nDataFrame.merge(right, how='inner', on=None, \n                left_on=None, right_on=None, \n                left_index=False, right_index=False, \n                sort=False, suffixes=('_x', '_y'))\n```\n\nWe'll replace ``DataFrame`` and ``right`` with the names of the two dataframes we want to merge (respectively). In the subsections below, we explain what the different choices for ``how`` mean. When the key(s) on which we want to merge have the same name(s) in the two datasets, we use the ``on`` parameter to specify the names of the keys (see the example immediately below), otherwise we need to specify them using the ``left_on`` and ``right_on`` parameters.\n\nThe documentation at https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html has some additional examples that you may find useful.\n\n### Inner join\n\nThe inner join combines the datasets based on the INTERSECTION of the values in the \"key\" columns.\n\nFor example, if we want to inner merge the two dataframes using the ``year`` column as a key:\n\nBut if we want to merge on both ``year`` and ticker information, we can not use ``on`` because the ticker information has different names in the different dataframes:\n\nNote how the name of the ``fy`` column in each of the two datasets has been changed. To control that process ourselves, we can use the ``suffixes`` parameter to specify suffixes that should be appended at the end of common column names:\n\n### Outer join\n\nThe outer join combines the datasets based on the UNION of the values in the \"key\" columns. For example:\n\n### Left join\n\nIn a left join, the unmatched keys from the left dataset are kept, but the unmatched keys from the right dataset are discarded.\n\n### Right join\n\nIn a right join, the unmatched keys from the right dataset are kept, but the unmatched keys from the left dataset are discarded.\n\n## Merging on index using ``.join()`` (and ``.merge()``)\n\nAs mentioned above, this covers the situation when the keys on which we want to perform the merge are indexes in the dataframes we want to merge. In this case, we can either use the ``.merge()`` function and specify ``left_index=True, right_index=True``, or we can use the ``.join()`` funciton without specifying any keys at all (because ``.join()`` assumes that you are using the index):\n\nFirst, let's add an index (MultiIndex) to the two dataframes: \n\nBefore we can use ``.merge()``, we have to make the index names match (``tic`` does not match ``ticker``):\n\nNow, say we want to perform an outer merge on the index:\n\nUsing the ``.join()`` function will not work unless we specify how the ``fy`` columns need to be renamed. We use the ``lsuffix`` and ``rsuffix`` parameters for this purpose.\n\nSyntax:\n```python\nDataFrame.join(other, on=None, how='left', lsuffix='', rsuffix='', sort=False)\n```\n\nFor example, we can perform the same outer merge as above using:\n\n# Concatenating  datasets with ``.concat()``\n\nWhen we say that we want to \"concatenate\" two datasets, we generally mean that we want the columns of the two datasets to be stacked on top of each other (vertically) or side by side (horizontally). We usually want to concatenate vertically (aka \"appending\") when we obtain more data on a given set of variables, and we just want to add it at the bottom of a dataset already containing those variables (columns).\n\nUnlike merging, concatenating horizontally means that we want to combine two datasets side by side, but \"as they are\", without concern for matching rows in any meaningful way (like merge). This is usually done when we want to combine different pieces of information (columns) from the two datasets, and we are certain that existing datasets are already organized in such a way that the rows will match meaningfully.\n\nThe ``.concat()`` function can perform both types of concatenation (it can also perform a merge but we will not use it for that purpose in this course):\n\nSyntax:\n```python\npandas.concat(objs, axis=0, join='outer', ignore_index=False, keys=None, levels=None, names=None, sort=False, copy=True)\n```\n\nWe specify ``axis=0`` for vertical concatenation and ``axis=1`` for horizontal concatenation:\n\nNote that, ``.concat()`` with ``axis=1`` is equivalent to ``.join()`` with ``how='outer'``. In other words, ``.concat()`` performs a merge on index. Its default ``join`` argument is set to ``outer`` but you can change that to perform any kind of join you want.\n\n# Reshaping datasets\n\nBy reshaping a dataset we generally mean that we want to change the structure of the dataset so that either\n\n1. Some data stored in one column is converted to multiple columns (but the same row)\n    - In pandas, this is called \"unstacking\"\n    - Informally, we say that we are converting the dataset from long to wide\n    \nor\n\n2. Some data stored in multiple columns (but the same row) is converted to a single column\n    - In pandas, this is called \"stacking\"\n    - Informally, we say that we are converting the dataset from wide to long\n      \nSee the official user guide page for more details on reshaping: https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html \n\n## From long to wide (unstacking) with ``.pivot()``\n\nSyntax:\n```python\nDataFrame.pivot(index=None, columns=None, values=None)\n```\n\nLet's create an example dataset:\n\nFor example, if we want to reshape the ``return`` data so that each ``year`` gets its own row (index value), and each ``portfolio`` gets its own column, we would use:\n\nIf we want to reshape both the ``return`` data and the ``nfirms`` data in the same way, at the same time:\n\nNote that now the column labels are two-dimensional:\n\nUnstacking based on values in the index can be done using the ``.unstack()`` function (usually for datasets with a MultiIndex).\n\n## From wide to long (stacking) with ``.stack()``\n\nWe can stack the data back up to a \"long\" shape, based on information in the index of that dataframe.\n\nSyntax:\n```python\nDataFrame.stack(level=-1, dropna=True)\n```\n\nThe ``level`` parameter is used in case the dataframe we want to reshape has a MultiIndex in the columns i.e. multi-dimensional column names (like ``wide2`` above). The default ``level=-1`` works for dataframes that were reshaped from a different dataframe (like ``wide2`` above). In that case ``level=-1`` tells Python to just undo that reshaping:\n\nIf we want to stack the information in the first dimension of the column MultiIndex (i.e. the part that contains \"return\" and \"nfirms\"), then we use ``level=0``:\n\nIf we want to stack the information in the second dimension of the column MultiIndex (i.e. the part that contains 1's and 2's), then we use ``level=1``:\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"lecture10_merging_reshaping.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"zephyr","page-layout":"full","grid":{"sidebar-width":"400px"},"title":"L10: Merging, reshaping datasets"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}