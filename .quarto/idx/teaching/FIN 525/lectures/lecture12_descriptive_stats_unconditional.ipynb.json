{"title":"L12: Descriptive stats","markdown":{"yaml":{"title":"L12: Descriptive stats"},"headingText":"Preliminaries","containsRefs":false,"markdown":"\n\n\n# Vizualization tools (the ``.plot()`` function)\n\nThere are many different ways to visualize the data from a Pandas dataframe (e.g. the ``matplotlib`` and ``seaborn`` packages are very popular). However, for the purpose of this class, the ``.plot()`` function that comes with the Pandas package will be sufficient.\n\nBelow we work through some examples of the most common types of plots used for financial data: line plots, scatter plots, histograms, and box plots.\n\nAbbreviated syntax:\n```python\nDataFrame.plot(kind = 'line', x = None, y = None, \n               title = None, xlabel = None, ylabel = None,\n               legend = True, grid = False, layout = None, \n               sharex = True, sharey = False, figsize = None)\n```\n\nMore detail on the ``.plot()`` function can be found here:\nhttps://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html\n\n## Line plots\n\nNote that, by default, ``plot()`` creates a \"line\" plot, using the index of the dataframe for the x axis (in our case, the Date):\n\nYou can specify which variables you want plotted by subsetting the overall dataframe first:\n\nBelow, we show more of the functionality of ``.plot()`` through a more involved example:\n\n## Scatter plots\nTo create a scatter plot, we need to change the ``kind`` parameter to \"scatter\" and also specify what is on the x axis and what is on the y axis:\n\n## Histograms\nFor a histogram, we use ``kind='hist'`` and then use ``subplots=True`` to specify that we want each variable to have its own histogram, in a separate subplot:\n\nWe can change the position of the subplots relative to each other using the ``layout`` parameter:\n\nWe can create a continuous approximation of the histogram using ``kind='density'``:\n\n## Box plots\n\nFor box plots, we use ``kind='box'``:\n\n# Single-variable statistics\n\nWe start by looking at statistics that describe a single variable (as opposed to the relationship between two variables). \n\nSince our data will almost always be in a Pandas dataframe, we will use pandas functions (attributes) to calculate sample statistics, but many other packages can be used to calculate summary statistics for your data (e.g. the ``numpy`` package allows you to calculate descriptive statistics if your data is in a Numpy array).\n\n## The ``.describe()`` function\n\nWe can use the  ``.describe()`` function to get some standard descriptive statistics for the entire dataset. \n\nSyntax:\n```python\nDataFrame.describe(percentiles=None, include=None, exclude=None, datetime_is_numeric=False)\n```\n\nThe default is for ``.describe()`` to produce summary statistics only for numerical data types in the dataframe. You can change this with the ``include`` and ``exclude`` parameters. \n\nThe ``percentiles`` parameter allows you to specify which percentiles you want ``.describe()`` to calculate (default is 25th, 50th and 75th percentiles). For example, below, we only ask for the 50th percentile (the median):\n\n## Calculating individual statistics\n\nEach individual statistic produced by ``.describe()`` has its own function that can be applied either to the entire dataframe or to subsets of it. Below I only show examples for mean, variance, standard deviation and median (but you can also use ``.count()``, ``.min()``, ``.max()``, ``.sum()`` and many others).\n\n### ``.mean()``\n\n### ``.var()``\n\n### ``.std()``\n\n### ``.median()``\n\n**Challenge:**\n\nNote that the output of ``.describe()`` is also a dataframe. So we can use ``.loc[]`` to access specific numbers in that output table.\n\nUse the space below to calculate and print the interquartile range (IQR = percentile 75 minus percentile 25) for the 'MKT' variable:\n\n## Calculating row-level statistics\n\nAll statistical functions in Pandas (e.g. ``.mean()``, ``.median()``, etc) have an ``axis`` argument that allows you to specify if you want that statistic to be calculated column-wise (axis=0, the default) or row-wise (axis=1). \n\nFor example, if we want to know, each month, which of the columns in ``ff3`` had the highest return, we would use:\n\nAs usual, we can also calculate row-wise statistics using only a subset of the columns:\n\n## Creating your own list of summary statistics with the ``.agg()`` function\n\nIf we want a different selection of summary statistics than the one offered by the ``.describe()`` function, we can use the ``.agg()`` function to specify exactly which statistics we want:\n\nSyntax:\n```python\nDataFrame.agg(func=None, axis=0, *args, **kwargs)\n```\n\nIf you want the same stats for all variables, just provide a list of the names of the functions you want to be used (e.g. use 'mean' for the ``.mean()`` function, 'std' for the ``.std()`` function etc.).\n\nYou can also specify different functions (stats) for each variable:\n\n**Challenge:**\n\nCreate a table that shows just the mean and standard deviation for the SMB and HML variables\n\n# Two-variable statistics\n\nThese are statistics that describe the relation between two variables. The most commonly used ones are the **covariance* and the **correlation**. Both of these try to quantify the strength of the **linear** relation between the two variables. The main difference between them is that the correlation coefficient is bounded between -1 and 1 and so it is easier to interpret. \n\n*If two variables are tightly related to each other, but not in a linear fashion (e.g. $Y = X^4$), the covariance and correlation will **underestimate** the strength of that relation.*\n\n## Covariance: ``.cov()``\n\nThe ``cov()`` function produces a covariance matrix for the variables (columns) in the dataframe. The numbers on the diagonal are actually variances. Each number on the off-diagonal is the covariance between the two variables specified in the column/row headers.\n\nThe output table above is a dataframe, so we can access individual numbers in it using the ``.loc[]`` operator. \n\nFor example, below, we extract the covariance between the 'MKT' and 'SMB' variables:\n\nRemember, if you want to use these estimates later on, you need to store them as new variables:\n\n## Correlation: ``.corr()``\n\nJust like with covariance, we can calculate a correlation matrix for the entire dataset:\n\nOr we can extract the correlation of a particular pair of variables in your dataset:\n\n**Challenge:**\n\nCalculate the correlation between 'MKT' returns in the current month and the SMB return from 12 months ago.\n\n## Autocorrelation: ``.autocorr()``\n\nThe autocorrelation of a variable is the correlation between its current value and a value from the past. So there is not one single autocorrelation for any given variable, there is one autocorrelation for every \"lag\" between the current value and the value from the past. For example, below, we calculate the \"1-month autocorrelation\" and \"12-month autocorrelation\" for the market portfolio returns:\n\nAnd below we verify that the autocorrelation is nothing but the correlation between the current value and a lagged value:\n\n# Rolling statistics\n\nThese are statistics that are re-calculated at each point in time, using either \n- a fixed number of data points from the past \n    - these are called \"fixed window\" rolling statistics\n    - can be calculated with the \"rolling\" Pandas function\n- all the data from the past (expanding window) \n    - these are called \"expanding window\" rolling statistics\n    - can be calculated with the \"expanding\" Pandas function\n\nBoth the \"expanding\" and the \"rolling\" functions should be followed by the name of the statistic that you want to calculate.\n\n## Fixed-window rolling statistics \n\nWe use the ``.rolling()`` function to calculate summary statistics at each point in time \"t\" using only the observations from \"t - w\" to \"t\", where \"w\" is referred to as the \"window\" length.\n\nSyntax:\n```python\nDataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None, method='single')\n```\n\nAs an example, below, we calculate 60-month rolling means (i.e. \"w\" is 60) for all the variables in ``ff3``:\n\nWe can calculate rolling versions for all summary statistics that the pandas package knows how to calculate. For example, below, we calculate the rolling, 36-month standard deviations of market returns, and we plot these over time:\n\nWe can even calculate rolling versions of two-variable summary statistics (like correlation and covariance). However, we have to remember that ``.corr()`` and ``.cov()`` produce matrices not single numbers. So if we want rolling correlations between, say, market returns and the risk-free rate, the cell below will produce a correlation matrix at each point in time:\n\nInstead, we need to supply one of the variables as a parameter to the ``.corr()`` function:\n\n## Expanding-window rolling statistics\n\nWith expanding-window summary statistics, at each point in time, we use all the available data up to that point to calculate the statistic. We use the ``.expanding()`` function for this purpose, which also gives us the option to specify that we want to calculate the statistic only if we have a minimum number of observations available at that point (see the ``min_period`` parameter below): \n\nSyntax:\n```python\nDataFrame.expanding(min_periods=1, center=None, axis=0, method='single')\n```\n\nNote that, if we don't supply a large enough ``min_periods``, in the beginning of the sample, the statistics will be calculated using a very low number of observations (starting with 1), so they will be quite volatile:\n\nThis looks a lot more stable if we make sure each statistic is calculated using at least 36 observations:\n\nAs another example, let's look at the behavior of market volatility over time:\n\nFinally, below, we see that the correlation between market returns and tbill yields, while changing over time, is negative throughout (when we do not restrict ourselves to just the prior 60 observations):\n","srcMarkdownNoYaml":"\n\n# Preliminaries\n\n# Vizualization tools (the ``.plot()`` function)\n\nThere are many different ways to visualize the data from a Pandas dataframe (e.g. the ``matplotlib`` and ``seaborn`` packages are very popular). However, for the purpose of this class, the ``.plot()`` function that comes with the Pandas package will be sufficient.\n\nBelow we work through some examples of the most common types of plots used for financial data: line plots, scatter plots, histograms, and box plots.\n\nAbbreviated syntax:\n```python\nDataFrame.plot(kind = 'line', x = None, y = None, \n               title = None, xlabel = None, ylabel = None,\n               legend = True, grid = False, layout = None, \n               sharex = True, sharey = False, figsize = None)\n```\n\nMore detail on the ``.plot()`` function can be found here:\nhttps://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html\n\n## Line plots\n\nNote that, by default, ``plot()`` creates a \"line\" plot, using the index of the dataframe for the x axis (in our case, the Date):\n\nYou can specify which variables you want plotted by subsetting the overall dataframe first:\n\nBelow, we show more of the functionality of ``.plot()`` through a more involved example:\n\n## Scatter plots\nTo create a scatter plot, we need to change the ``kind`` parameter to \"scatter\" and also specify what is on the x axis and what is on the y axis:\n\n## Histograms\nFor a histogram, we use ``kind='hist'`` and then use ``subplots=True`` to specify that we want each variable to have its own histogram, in a separate subplot:\n\nWe can change the position of the subplots relative to each other using the ``layout`` parameter:\n\nWe can create a continuous approximation of the histogram using ``kind='density'``:\n\n## Box plots\n\nFor box plots, we use ``kind='box'``:\n\n# Single-variable statistics\n\nWe start by looking at statistics that describe a single variable (as opposed to the relationship between two variables). \n\nSince our data will almost always be in a Pandas dataframe, we will use pandas functions (attributes) to calculate sample statistics, but many other packages can be used to calculate summary statistics for your data (e.g. the ``numpy`` package allows you to calculate descriptive statistics if your data is in a Numpy array).\n\n## The ``.describe()`` function\n\nWe can use the  ``.describe()`` function to get some standard descriptive statistics for the entire dataset. \n\nSyntax:\n```python\nDataFrame.describe(percentiles=None, include=None, exclude=None, datetime_is_numeric=False)\n```\n\nThe default is for ``.describe()`` to produce summary statistics only for numerical data types in the dataframe. You can change this with the ``include`` and ``exclude`` parameters. \n\nThe ``percentiles`` parameter allows you to specify which percentiles you want ``.describe()`` to calculate (default is 25th, 50th and 75th percentiles). For example, below, we only ask for the 50th percentile (the median):\n\n## Calculating individual statistics\n\nEach individual statistic produced by ``.describe()`` has its own function that can be applied either to the entire dataframe or to subsets of it. Below I only show examples for mean, variance, standard deviation and median (but you can also use ``.count()``, ``.min()``, ``.max()``, ``.sum()`` and many others).\n\n### ``.mean()``\n\n### ``.var()``\n\n### ``.std()``\n\n### ``.median()``\n\n**Challenge:**\n\nNote that the output of ``.describe()`` is also a dataframe. So we can use ``.loc[]`` to access specific numbers in that output table.\n\nUse the space below to calculate and print the interquartile range (IQR = percentile 75 minus percentile 25) for the 'MKT' variable:\n\n## Calculating row-level statistics\n\nAll statistical functions in Pandas (e.g. ``.mean()``, ``.median()``, etc) have an ``axis`` argument that allows you to specify if you want that statistic to be calculated column-wise (axis=0, the default) or row-wise (axis=1). \n\nFor example, if we want to know, each month, which of the columns in ``ff3`` had the highest return, we would use:\n\nAs usual, we can also calculate row-wise statistics using only a subset of the columns:\n\n## Creating your own list of summary statistics with the ``.agg()`` function\n\nIf we want a different selection of summary statistics than the one offered by the ``.describe()`` function, we can use the ``.agg()`` function to specify exactly which statistics we want:\n\nSyntax:\n```python\nDataFrame.agg(func=None, axis=0, *args, **kwargs)\n```\n\nIf you want the same stats for all variables, just provide a list of the names of the functions you want to be used (e.g. use 'mean' for the ``.mean()`` function, 'std' for the ``.std()`` function etc.).\n\nYou can also specify different functions (stats) for each variable:\n\n**Challenge:**\n\nCreate a table that shows just the mean and standard deviation for the SMB and HML variables\n\n# Two-variable statistics\n\nThese are statistics that describe the relation between two variables. The most commonly used ones are the **covariance* and the **correlation**. Both of these try to quantify the strength of the **linear** relation between the two variables. The main difference between them is that the correlation coefficient is bounded between -1 and 1 and so it is easier to interpret. \n\n*If two variables are tightly related to each other, but not in a linear fashion (e.g. $Y = X^4$), the covariance and correlation will **underestimate** the strength of that relation.*\n\n## Covariance: ``.cov()``\n\nThe ``cov()`` function produces a covariance matrix for the variables (columns) in the dataframe. The numbers on the diagonal are actually variances. Each number on the off-diagonal is the covariance between the two variables specified in the column/row headers.\n\nThe output table above is a dataframe, so we can access individual numbers in it using the ``.loc[]`` operator. \n\nFor example, below, we extract the covariance between the 'MKT' and 'SMB' variables:\n\nRemember, if you want to use these estimates later on, you need to store them as new variables:\n\n## Correlation: ``.corr()``\n\nJust like with covariance, we can calculate a correlation matrix for the entire dataset:\n\nOr we can extract the correlation of a particular pair of variables in your dataset:\n\n**Challenge:**\n\nCalculate the correlation between 'MKT' returns in the current month and the SMB return from 12 months ago.\n\n## Autocorrelation: ``.autocorr()``\n\nThe autocorrelation of a variable is the correlation between its current value and a value from the past. So there is not one single autocorrelation for any given variable, there is one autocorrelation for every \"lag\" between the current value and the value from the past. For example, below, we calculate the \"1-month autocorrelation\" and \"12-month autocorrelation\" for the market portfolio returns:\n\nAnd below we verify that the autocorrelation is nothing but the correlation between the current value and a lagged value:\n\n# Rolling statistics\n\nThese are statistics that are re-calculated at each point in time, using either \n- a fixed number of data points from the past \n    - these are called \"fixed window\" rolling statistics\n    - can be calculated with the \"rolling\" Pandas function\n- all the data from the past (expanding window) \n    - these are called \"expanding window\" rolling statistics\n    - can be calculated with the \"expanding\" Pandas function\n\nBoth the \"expanding\" and the \"rolling\" functions should be followed by the name of the statistic that you want to calculate.\n\n## Fixed-window rolling statistics \n\nWe use the ``.rolling()`` function to calculate summary statistics at each point in time \"t\" using only the observations from \"t - w\" to \"t\", where \"w\" is referred to as the \"window\" length.\n\nSyntax:\n```python\nDataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None, method='single')\n```\n\nAs an example, below, we calculate 60-month rolling means (i.e. \"w\" is 60) for all the variables in ``ff3``:\n\nWe can calculate rolling versions for all summary statistics that the pandas package knows how to calculate. For example, below, we calculate the rolling, 36-month standard deviations of market returns, and we plot these over time:\n\nWe can even calculate rolling versions of two-variable summary statistics (like correlation and covariance). However, we have to remember that ``.corr()`` and ``.cov()`` produce matrices not single numbers. So if we want rolling correlations between, say, market returns and the risk-free rate, the cell below will produce a correlation matrix at each point in time:\n\nInstead, we need to supply one of the variables as a parameter to the ``.corr()`` function:\n\n## Expanding-window rolling statistics\n\nWith expanding-window summary statistics, at each point in time, we use all the available data up to that point to calculate the statistic. We use the ``.expanding()`` function for this purpose, which also gives us the option to specify that we want to calculate the statistic only if we have a minimum number of observations available at that point (see the ``min_period`` parameter below): \n\nSyntax:\n```python\nDataFrame.expanding(min_periods=1, center=None, axis=0, method='single')\n```\n\nNote that, if we don't supply a large enough ``min_periods``, in the beginning of the sample, the statistics will be calculated using a very low number of observations (starting with 1), so they will be quite volatile:\n\nThis looks a lot more stable if we make sure each statistic is calculated using at least 36 observations:\n\nAs another example, let's look at the behavior of market volatility over time:\n\nFinally, below, we see that the correlation between market returns and tbill yields, while changing over time, is negative throughout (when we do not restrict ourselves to just the prior 60 observations):\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"lecture12_descriptive_stats_unconditional.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"zephyr","page-layout":"full","grid":{"sidebar-width":"400px"},"title":"L12: Descriptive stats"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}