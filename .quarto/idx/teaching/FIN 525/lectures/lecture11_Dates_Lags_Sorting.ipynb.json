{"title":"L11: Dates, lags, sorting","markdown":{"yaml":{"title":"L11: Dates, lags, sorting"},"headingText":"Date formats: \"pd.to_datetime()\" and \"dt.to_period()\"","containsRefs":false,"markdown":"\n\n\nPandas offers a lot of flexibility to manipulate dates and time stamps. Much of this functionality can only be used on columns that have the Pandas \"datetime\" data type. We can convert dates to this data type using the ``.to_datetime()`` function.\n\nFirst, not that the ``date`` column in our dataframe is of type \"object\":\n\nWe'll create a copy of the ``df`` dataframe to avoid changing the original data in ``df``:\n\nNow we can apply many useful date functions (they usually have the prefix ``dt.``) to this datetime variable. For example, we can extract information about specific components of the date:\n\nAnother common use of the ``.to_datetime()`` function is to construct a datetime variable from date components:\n\nThe other, very commonly used type for date data is the Pandas ``period`` format. This is used to specify that your data has a particular frequency, and can be done by applying the ``.to_period()`` function to a datetime variable (e.g. use 'Y' for yearly frequency data, 'M' for monthly, and 'Q' for quarterly):\n\nThese type of ``period`` date are useful for many operations on the data, the most important one being that Pandas understand what you mean if you want to add or subtract some number of periods from a given date. For example:\n\n# Sorting\n\nWe can sort a dataframe based on the values in a particular column using the ``.sort_values()`` function. To sort based on the values in an index, we use the ``.sort_index()`` function. \n\n## .sort_values()\nSyntax:\n```python\nDataFrame.sort_values(by, axis=0, ascending=True, inplace=False)\n```\n\nRemember, functions that have an ``inplace`` parameter do not actually change the original dataset unless we set that parameter to ``True``:\n\n## .sort_index()\nAbbreviated syntax:\n```python\nDataFrame.sort_index(axis=0, level=None, ascending=True, inplace=False)\n```\n\n# Lagging and leading\n\nIn the context of most financial datasets which contain time-indexed information, lagging a particular variable (column) means obtaining the values for that particular variable from a prior point in time. Leading a variable means obtaining values from a future point in time.\n\nIf you research how to lead and lag variables in with pandas dataframes, most sources (including the official Pandas user guide) claims that you can do this using the ``.shift()`` function. In this section I first show you how to use this method, and when it runs into problems. Then show you how you can create leads and lags in a more robust way (using ``period`` dates and the ``merge`` function).\n\n\n## Lagging and leading using ``.shift()``\n\nSyntax:\n```python\nDataFrame.shift(periods=1, freq=None, axis=0, fill_value=NoDefault.no_default)\n```\n\nSuppose we want to create a new column ``lag_return`` which tells us, for each firm, its returns from **the prior month**.\nThe general advice you'll see is that you should first sort your dataframe by firm identifier and by date:\n\nAnd then use the ``.shift()`` function, after you tell Python that your dates are grouped at the firm level (each firm identifier has its own set of dates):\n\nNote that the entries for ``lag_ret`` on the second row and the last row are not correct: they do not tell us what the return of the firm was in the prior month. This happens because \n\n1. Our data has gaps in coverage (October 2010 is missing for firmid==1)\n2. Our data has duplicates (there are two entries for December 2010 for firmid==3)\n\nNote that both of these issues disappear if we first get rid of duplicates and if we reinterpret \"lagging\" to mean \"the last available data point\" not \"data from the last calendar period\" and \"leading\" to mean \"the next available data point\" and not \"data from the following calendar period\". To keep things simple, **this is the approach we will take in this course**.\n\nHowever, if this reinterpretation of lagging and leading is not exactly what you need for your application and you need to lag and lead in terms of calendar periods, you should follow the approach below:\n\n## Leading and lagging with ``.merge()``\n\nFirst, again, create a copy of the original dataset:\n\nWe will first create a new date variable that tells Python the frequency of our dates:\n\nNow create a new dataframe containing the firm identifiers (``firmid``), the period date (``mdate``) and the variable we want to lag (``return``):\n\nNow add (subtract in case of leads) the number of periods you want to lag the return variable (1 in our example) to the period date:\n\nAnd rename ``return`` to ``lag_return``:\n\nFinally, merge this lagged data into the original dataset:\n\nNote that now the second and last entry in ``lag_return`` are correct. \n\nYou still have to contend with what it means that you have duplicate entries for ``return`` for December 2010 for ``firmid==3`` but dealing with duplicates needs to be addressed on a case by case basis, depending on the particulars of the data you are using.\n","srcMarkdownNoYaml":"\n\n# Date formats: \"pd.to_datetime()\" and \"dt.to_period()\"\n\nPandas offers a lot of flexibility to manipulate dates and time stamps. Much of this functionality can only be used on columns that have the Pandas \"datetime\" data type. We can convert dates to this data type using the ``.to_datetime()`` function.\n\nFirst, not that the ``date`` column in our dataframe is of type \"object\":\n\nWe'll create a copy of the ``df`` dataframe to avoid changing the original data in ``df``:\n\nNow we can apply many useful date functions (they usually have the prefix ``dt.``) to this datetime variable. For example, we can extract information about specific components of the date:\n\nAnother common use of the ``.to_datetime()`` function is to construct a datetime variable from date components:\n\nThe other, very commonly used type for date data is the Pandas ``period`` format. This is used to specify that your data has a particular frequency, and can be done by applying the ``.to_period()`` function to a datetime variable (e.g. use 'Y' for yearly frequency data, 'M' for monthly, and 'Q' for quarterly):\n\nThese type of ``period`` date are useful for many operations on the data, the most important one being that Pandas understand what you mean if you want to add or subtract some number of periods from a given date. For example:\n\n# Sorting\n\nWe can sort a dataframe based on the values in a particular column using the ``.sort_values()`` function. To sort based on the values in an index, we use the ``.sort_index()`` function. \n\n## .sort_values()\nSyntax:\n```python\nDataFrame.sort_values(by, axis=0, ascending=True, inplace=False)\n```\n\nRemember, functions that have an ``inplace`` parameter do not actually change the original dataset unless we set that parameter to ``True``:\n\n## .sort_index()\nAbbreviated syntax:\n```python\nDataFrame.sort_index(axis=0, level=None, ascending=True, inplace=False)\n```\n\n# Lagging and leading\n\nIn the context of most financial datasets which contain time-indexed information, lagging a particular variable (column) means obtaining the values for that particular variable from a prior point in time. Leading a variable means obtaining values from a future point in time.\n\nIf you research how to lead and lag variables in with pandas dataframes, most sources (including the official Pandas user guide) claims that you can do this using the ``.shift()`` function. In this section I first show you how to use this method, and when it runs into problems. Then show you how you can create leads and lags in a more robust way (using ``period`` dates and the ``merge`` function).\n\n\n## Lagging and leading using ``.shift()``\n\nSyntax:\n```python\nDataFrame.shift(periods=1, freq=None, axis=0, fill_value=NoDefault.no_default)\n```\n\nSuppose we want to create a new column ``lag_return`` which tells us, for each firm, its returns from **the prior month**.\nThe general advice you'll see is that you should first sort your dataframe by firm identifier and by date:\n\nAnd then use the ``.shift()`` function, after you tell Python that your dates are grouped at the firm level (each firm identifier has its own set of dates):\n\nNote that the entries for ``lag_ret`` on the second row and the last row are not correct: they do not tell us what the return of the firm was in the prior month. This happens because \n\n1. Our data has gaps in coverage (October 2010 is missing for firmid==1)\n2. Our data has duplicates (there are two entries for December 2010 for firmid==3)\n\nNote that both of these issues disappear if we first get rid of duplicates and if we reinterpret \"lagging\" to mean \"the last available data point\" not \"data from the last calendar period\" and \"leading\" to mean \"the next available data point\" and not \"data from the following calendar period\". To keep things simple, **this is the approach we will take in this course**.\n\nHowever, if this reinterpretation of lagging and leading is not exactly what you need for your application and you need to lag and lead in terms of calendar periods, you should follow the approach below:\n\n## Leading and lagging with ``.merge()``\n\nFirst, again, create a copy of the original dataset:\n\nWe will first create a new date variable that tells Python the frequency of our dates:\n\nNow create a new dataframe containing the firm identifiers (``firmid``), the period date (``mdate``) and the variable we want to lag (``return``):\n\nNow add (subtract in case of leads) the number of periods you want to lag the return variable (1 in our example) to the period date:\n\nAnd rename ``return`` to ``lag_return``:\n\nFinally, merge this lagged data into the original dataset:\n\nNote that now the second and last entry in ``lag_return`` are correct. \n\nYou still have to contend with what it means that you have duplicate entries for ``return`` for December 2010 for ``firmid==3`` but dealing with duplicates needs to be addressed on a case by case basis, depending on the particulars of the data you are using.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"lecture11_Dates_Lags_Sorting.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"zephyr","page-layout":"full","grid":{"sidebar-width":"400px"},"title":"L11: Dates, lags, sorting"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}