{"title":"L14: Conditional stats applied","markdown":{"yaml":{"title":"L14: Conditional stats applied"},"headingText":"Lecture overview","containsRefs":false,"markdown":"\n\n\nLoosely speaking, \"conditional descriptive statistics\" are statistics calculated for subsamples (subsets) of your data. The information you use to create these subsamples is referred to as the \"conditioning information\". In this lecture, we showcase these types of descriptive statistics using the tools learned in the previous lecture, and a panel dataset: the \"compa\" file, which contains accounting information for multiple firms over multiple years. \n\nIn the previous lecture we calculated conditional statistics in situations where the variable which dictated what observations are in what subsample already exists in the dataset. For example, we calculated average returns for each industry separately. In that example, the returns of each individual industry constitute a separate subsample of our data. The \"conditioning information\" which allowed us to specify which observation was in what sample was the \"Industry\" variable (which already existed in the dataset).\n\nIn this lecture, we will focus on examples where we have to create ourselves the variable which specifies which observation is in what sample. \n\n# Preliminaries\n\nGet raw data:\n\nClean it up a bit:\n\nCreate a new dataframe with firm and year identifiers for firms with positive total assets:\n\nAnd calculate some key variables:\n\n**Challenge**\n\nWinsorize the 'inv','roa','lev','cash' variables at the 1 and 99th percentiles and get full-sample summary statistics for them.\n\nCompare the standard deviations of the winsorized variables above, to the standard deviation of the un-wisnorized variables: \n\nSave the names of the main variables we want to analyze into a list, so we don't have to type them up every time we use them:\n\n# Subperiod analysis\n\nIt is often a good idea to test how the results of your analysis change depending on the time period included in the data. This type of testing is generally referred to as \"subperiod analysis\". We'll cover two such examples below.\n\nIn the following example, we calculate means of our key variables **each year** and plot these means to see how they have changed over time.\n\nAs another example, we now calculate our means separately for the period prior to the year 2000, and the period after. \n\nTo do this, we need to create a new variable in our dataframe that takes one value prior to 2000 and a different value after 2000. *What* these values are, does not matter at all, they just have to be two different values in the pre-2000 and post-2000 eras. An easy way to do this is with the ``where`` function in the ``numpy`` package. This function works exactly like ``if`` in Excel:\n\nSyntax:\n```python\nnumpy.where(condition, x, y)\n```\nWhen the condition is true, this returns the value x, and when it is false, it returns the value y.\n\nWe can now use the \"pre_post_2000\" variable with ``.groupby()`` to calculate means separately in the two subperiods:\n\n# Conditioning on cross-sectional information\n\nOur panel dataset has information for many different firms, each year. We refer to the totality of the firms in our sample as the \"cross-sectional\" dimension of the data (as opposed to the \"time\" dimension).\n\nIn the examples below, we calculate means of our key variables for each sector in the economy. For each sector, we use all the data available for that sector (i.e. all years for all firms in that sector). This means we will have a single mean per sector.\n\nIn our example, separate \"sectors\" are identified by the first digit of the SIC (industry) code of the firm (the \"sich\" variable in the \"comp\" dataframe). So this is another example in which we have to create a new variable that specifies which observation is in which subsample (sector).\n\nWe do this by first turning \"sich\" into a string variable (with ``.astype('string')``) and then selecting the first character in that string (with ``.str[0]``):\n\nLet's see how many observations we have for each sector:\n\nIf you look up the SIC codes:\n\nhttps://siccode.com/sic-code-lookup-directory\n\nyou'll see that, roughly speaking, 3 stands for manufacturing firms (though 2 does as well), and 6 stands for financial firms. So the two largest sectors represented in our sample are manufacturing and finance.\n\nFinally, we calculate sector-level means for each of the main variables, using \"sic1d\" with the ``groupby`` function. Note how much these statistics differ across sectors:\n\n# Conditioning on both time and the cross-section\n\nFinally, we showcase an example where we examine how summary statistics vary across groups of firms **and** over time. \n\nIn the example below, we calculate means of our key variables for each sector in the economy, for each year separately. For each sector, we take an average over all the firms in that sector, separately for each year that the sector exists in our dataset. This means we will have a time-series of means for each sector.\n\nWe now plot some of these sector-specific means to see how they have changed over time. To create these plots, we use the **unstack** function to unstack the industries so their data show up side by side (instead of on top of each other).\n\nNote that the column labels have two components: one component that tells us which variable is being summarized, and one component that tells us which sector is being summarized:\n\nLet's look at the evolution of investment in particular:\n\nNote that the column names are actually strings, not integers:\n\nNote also that in the first few years, we have lots of missing data for the 'sich' variable, which is why we have so many \"NaN\" values in the table above. We use ``.dropna()`` to eliminate all the years in which we have \"NaN\" values:\n\nSector 1 is \"Mining and Construction\" and Sector 6 is \"Financials\" so it makes sense that they have drastically different levels of physical investment. To plot just those two sectors, we have to use ``.loc[]`` to extract them from the overall dataframe before we use ``.plot()``: \n\nTo test yourself, see if you can tell why the line below produces the same result:\n\n**Challange**:\n\nCreate a similar plot to the one above, but this time for profitability (roa). Also, this time, place each sector (1 and 6) in a separate subplot. \n\n# Advanced \"binning\" example \n\nIn many cases, our analysis requires us to split our sample in bins (groups) based on how firms rank in terms of one specific variable. Then some analysis is performed separately for each bin. \n\nTo showcase this type of subsample analysis, in the examples below, we analyze if the evolution of cash holdings over time looks different for firms with different levels of profitability.\n\nTo do this, we need to define what we mean by \"different levels of profitability\". One approach could be to use specific values of profitability: e.g. put all firms with ROA larger than 20\\% in a \"high profitability\" bin, etc. However, these levels would be a bit arbitrary (why 20\\% and not 25\\%). \n\nInstead, a more common approach is to simply split firms into a number of equaly sized bins (same number of firms in each bin). For example, below, we split firms into 5 equaly-sized \"bins\" based on how their profitability ranks among the rest of profitability data (5 equaly-size groups are often called \"quintiles\", 4 = \"quartiles\", 3 = \"terciles, 10 = \"deciles\")\n\nFirst, let's look again at how average cash-holdings evolve over time, when we use the full cross-section:\n\nNow we can use the ``.qcut()`` function to create the 5 profitability bins.\n\nSyntax:\n```python\npandas.qcut(x, q, labels=None, retbins=False, precision=3, duplicates='raise')\n```\n\nAnd check that these are \"equally-sized bins\":\n\nNow take a look at the trends in cash holdings, separately, for firm in different ROA bins:\n\nIt looks like the strong positive trend in cash holdings is only there for firms with the lowest profitability.\n\n## Multi-dimensional bins\n\nIn the example below, we redo this analysis, but this time, to judge which firm goes into which ROA bin, we compare profitability levels only amongst firms in a given year (and we do this for all years).\n\nTo do this, we need to use the ``.transform()`` function we introduced in the last lecture. We supply ``pd.qcut`` as a parameter to ``.transform()``.  \n\nNote that the ``lambda x`` tells Python that, what follows after it (i.e. pd.qcut) should be seen as a function of x. So the line of code above splits the \"roa\" data in years, then, it takes the roa data each year, calls it \"x\" and then supplies it as an input to the ``pd.qcut()`` function. That function uses that roa information to split firms into quintiles (q=5) based on how their roa ranks amongst all other firms that year. These quintiles are given names 1 through 5 (labels = range(1,6)), and stored in a new column called \"roa_q\" inside the \"comp\" dataframe.  \n\nLet's take a look at these quintile, as well as the ones we created in the prior section, and the roa levels themselves: \n\nNow we recalculate cash holding trends separately for each ROA bin, using these new bins:\n\nThis looks very similar to what we found in the prior section: the result that \"firms seem to be holding a lot more cash now\" holds only for firms with the lowest profitability. What do you think could account for these findings? \n","srcMarkdownNoYaml":"\n\n# Lecture overview\n\nLoosely speaking, \"conditional descriptive statistics\" are statistics calculated for subsamples (subsets) of your data. The information you use to create these subsamples is referred to as the \"conditioning information\". In this lecture, we showcase these types of descriptive statistics using the tools learned in the previous lecture, and a panel dataset: the \"compa\" file, which contains accounting information for multiple firms over multiple years. \n\nIn the previous lecture we calculated conditional statistics in situations where the variable which dictated what observations are in what subsample already exists in the dataset. For example, we calculated average returns for each industry separately. In that example, the returns of each individual industry constitute a separate subsample of our data. The \"conditioning information\" which allowed us to specify which observation was in what sample was the \"Industry\" variable (which already existed in the dataset).\n\nIn this lecture, we will focus on examples where we have to create ourselves the variable which specifies which observation is in what sample. \n\n# Preliminaries\n\nGet raw data:\n\nClean it up a bit:\n\nCreate a new dataframe with firm and year identifiers for firms with positive total assets:\n\nAnd calculate some key variables:\n\n**Challenge**\n\nWinsorize the 'inv','roa','lev','cash' variables at the 1 and 99th percentiles and get full-sample summary statistics for them.\n\nCompare the standard deviations of the winsorized variables above, to the standard deviation of the un-wisnorized variables: \n\nSave the names of the main variables we want to analyze into a list, so we don't have to type them up every time we use them:\n\n# Subperiod analysis\n\nIt is often a good idea to test how the results of your analysis change depending on the time period included in the data. This type of testing is generally referred to as \"subperiod analysis\". We'll cover two such examples below.\n\nIn the following example, we calculate means of our key variables **each year** and plot these means to see how they have changed over time.\n\nAs another example, we now calculate our means separately for the period prior to the year 2000, and the period after. \n\nTo do this, we need to create a new variable in our dataframe that takes one value prior to 2000 and a different value after 2000. *What* these values are, does not matter at all, they just have to be two different values in the pre-2000 and post-2000 eras. An easy way to do this is with the ``where`` function in the ``numpy`` package. This function works exactly like ``if`` in Excel:\n\nSyntax:\n```python\nnumpy.where(condition, x, y)\n```\nWhen the condition is true, this returns the value x, and when it is false, it returns the value y.\n\nWe can now use the \"pre_post_2000\" variable with ``.groupby()`` to calculate means separately in the two subperiods:\n\n# Conditioning on cross-sectional information\n\nOur panel dataset has information for many different firms, each year. We refer to the totality of the firms in our sample as the \"cross-sectional\" dimension of the data (as opposed to the \"time\" dimension).\n\nIn the examples below, we calculate means of our key variables for each sector in the economy. For each sector, we use all the data available for that sector (i.e. all years for all firms in that sector). This means we will have a single mean per sector.\n\nIn our example, separate \"sectors\" are identified by the first digit of the SIC (industry) code of the firm (the \"sich\" variable in the \"comp\" dataframe). So this is another example in which we have to create a new variable that specifies which observation is in which subsample (sector).\n\nWe do this by first turning \"sich\" into a string variable (with ``.astype('string')``) and then selecting the first character in that string (with ``.str[0]``):\n\nLet's see how many observations we have for each sector:\n\nIf you look up the SIC codes:\n\nhttps://siccode.com/sic-code-lookup-directory\n\nyou'll see that, roughly speaking, 3 stands for manufacturing firms (though 2 does as well), and 6 stands for financial firms. So the two largest sectors represented in our sample are manufacturing and finance.\n\nFinally, we calculate sector-level means for each of the main variables, using \"sic1d\" with the ``groupby`` function. Note how much these statistics differ across sectors:\n\n# Conditioning on both time and the cross-section\n\nFinally, we showcase an example where we examine how summary statistics vary across groups of firms **and** over time. \n\nIn the example below, we calculate means of our key variables for each sector in the economy, for each year separately. For each sector, we take an average over all the firms in that sector, separately for each year that the sector exists in our dataset. This means we will have a time-series of means for each sector.\n\nWe now plot some of these sector-specific means to see how they have changed over time. To create these plots, we use the **unstack** function to unstack the industries so their data show up side by side (instead of on top of each other).\n\nNote that the column labels have two components: one component that tells us which variable is being summarized, and one component that tells us which sector is being summarized:\n\nLet's look at the evolution of investment in particular:\n\nNote that the column names are actually strings, not integers:\n\nNote also that in the first few years, we have lots of missing data for the 'sich' variable, which is why we have so many \"NaN\" values in the table above. We use ``.dropna()`` to eliminate all the years in which we have \"NaN\" values:\n\nSector 1 is \"Mining and Construction\" and Sector 6 is \"Financials\" so it makes sense that they have drastically different levels of physical investment. To plot just those two sectors, we have to use ``.loc[]`` to extract them from the overall dataframe before we use ``.plot()``: \n\nTo test yourself, see if you can tell why the line below produces the same result:\n\n**Challange**:\n\nCreate a similar plot to the one above, but this time for profitability (roa). Also, this time, place each sector (1 and 6) in a separate subplot. \n\n# Advanced \"binning\" example \n\nIn many cases, our analysis requires us to split our sample in bins (groups) based on how firms rank in terms of one specific variable. Then some analysis is performed separately for each bin. \n\nTo showcase this type of subsample analysis, in the examples below, we analyze if the evolution of cash holdings over time looks different for firms with different levels of profitability.\n\nTo do this, we need to define what we mean by \"different levels of profitability\". One approach could be to use specific values of profitability: e.g. put all firms with ROA larger than 20\\% in a \"high profitability\" bin, etc. However, these levels would be a bit arbitrary (why 20\\% and not 25\\%). \n\nInstead, a more common approach is to simply split firms into a number of equaly sized bins (same number of firms in each bin). For example, below, we split firms into 5 equaly-sized \"bins\" based on how their profitability ranks among the rest of profitability data (5 equaly-size groups are often called \"quintiles\", 4 = \"quartiles\", 3 = \"terciles, 10 = \"deciles\")\n\nFirst, let's look again at how average cash-holdings evolve over time, when we use the full cross-section:\n\nNow we can use the ``.qcut()`` function to create the 5 profitability bins.\n\nSyntax:\n```python\npandas.qcut(x, q, labels=None, retbins=False, precision=3, duplicates='raise')\n```\n\nAnd check that these are \"equally-sized bins\":\n\nNow take a look at the trends in cash holdings, separately, for firm in different ROA bins:\n\nIt looks like the strong positive trend in cash holdings is only there for firms with the lowest profitability.\n\n## Multi-dimensional bins\n\nIn the example below, we redo this analysis, but this time, to judge which firm goes into which ROA bin, we compare profitability levels only amongst firms in a given year (and we do this for all years).\n\nTo do this, we need to use the ``.transform()`` function we introduced in the last lecture. We supply ``pd.qcut`` as a parameter to ``.transform()``.  \n\nNote that the ``lambda x`` tells Python that, what follows after it (i.e. pd.qcut) should be seen as a function of x. So the line of code above splits the \"roa\" data in years, then, it takes the roa data each year, calls it \"x\" and then supplies it as an input to the ``pd.qcut()`` function. That function uses that roa information to split firms into quintiles (q=5) based on how their roa ranks amongst all other firms that year. These quintiles are given names 1 through 5 (labels = range(1,6)), and stored in a new column called \"roa_q\" inside the \"comp\" dataframe.  \n\nLet's take a look at these quintile, as well as the ones we created in the prior section, and the roa levels themselves: \n\nNow we recalculate cash holding trends separately for each ROA bin, using these new bins:\n\nThis looks very similar to what we found in the prior section: the result that \"firms seem to be holding a lot more cash now\" holds only for firms with the lowest profitability. What do you think could account for these findings? \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"lecture14_conditional_stats_applied.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"zephyr","page-layout":"full","grid":{"sidebar-width":"400px"},"title":"L14: Conditional stats applied"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}