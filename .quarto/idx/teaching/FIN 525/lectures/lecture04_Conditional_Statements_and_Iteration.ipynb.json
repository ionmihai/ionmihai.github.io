{"title":"L04: Conditionals, loops","markdown":{"yaml":{"title":"L04: Conditionals, loops"},"headingText":"Lecture Overview","containsRefs":false,"markdown":"\n\n\n# Conditional Statements (if / elif / else)\n\nConditional statements allow us to tell Python to run certain lines of code (statements) only if some condition is satisfied. The syntax for conditional statements in python is as follows:\n\n```python\nif <condition>:\n    <statement(s)>\nelif <condition>:\n    <statement(s)>\nelse:\n    <statement(s)>\n```\nNote that the \"<>\" symbols should not appear in your code. They just signify places where *you* are expected to input something. \n\nEach conditional statement must have exactly one \"if\" condition, any number of \"elif\" conditions (as long as they are all between \"if\" and \"else\") and zero or one \"else\" statements. Each if/elif/else block is called a **branch** of that conditional statement.\n\nLet's work through some examples to show exactly how these conditional statements function:\n\nIndentation matters: all lines of code under a particular if/else branch must have the same indent (which must be deeper than the indent of the if statement itself):\n\nThe order of the conditions matters: only the statements under the **first** true condition (from the top) will be executed:\n\nAnything that has a truth value (i.e. evaluates to True or False) can be supplied as the condition after an \"if\" or \"elif\" (but not after \"else\"):\n\nFrom the Python official documentation (https://docs.python.org/3/library/stdtypes.html):\n\nHere are most of the built-in objects considered false:\n\n- constants defined to be false: None and False.\n\n- zero of any numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)\n\n- empty sequences and collections: '', (), [], {}, set(), range(0)\n\nCompound conditions (joined by logical operators like \"and\", \"or\") can be supplied on any \"if\" and \"elif\". Just make sure each condition is in its own set of parentheses:\n\n# Iteration ('for' loops)\n\nThe concept of iteration is fundamental to all programming languages. Iteration is one of the key reasons why programming is so powerful: it allows us to do something repeatedly, with only a slight modification each time around. We'll explain what that means using lots of examples below, but first, here is the general syntax of a \"for\" loop - the most widely used method of iteration in Python: \n\n```python\nfor <var> in <iterable>:\n    <statement(s)>\n```\n\nFor example, in the loop below, \\<var\\> is i, \\<iterable\\> is the list \\[1, 'a', [2,3]\\], and \\<statement(s)\\> is the single line of code \"print(i)\"\n\nThe for loop \"iterates over\" (i.e. cycles through the elements of) the list \\[1, 'a', [2,3]\\]. Each time around, it assigns that element the name i, and then it executes the line(s) of code in the \"body\" of the for loop (i.e. \"print(i)\") in our example.\n\nSo the for loop above is equivalent to the following code:\n\nJust like with \"if\" statements, the body of the loop can contain multiple lines of code (statements), as long as they have the same indent:\n\nCan you tell why the following code does not produce the same output?\n\nThe \"iterable\" that we iterate over with the for loop, does not have to be a list. It can be any data structure with elements over which Python knows how to cycle (e.g. a tuple, a dictionary, a string, and many others):\n\nNote that the loop only iterates over the \"keys\" of the dictionary. If we want access to the \"values\" of the dictionary we have to use the \"values()\" attribute for dictionaries:\n\nThis dictionary example shows you that the behavior of the loop depends crucially on the nature of the iterable you supply it (i.e. Python may iterate over objects of different types in different ways). The easiest way to see how Python iterates over objects of a particular type is to just create an example of such a type and then print its elements in a loop.\n\nFor example, if you were curious how Python iterates over a nested list (a list of lists), you can use something like this:\n\n**The \"break\" statement**\n\nThe \"break\" command tells Python to exit the loop regardless of weather it has finished looping through the elements of its iterable:\n\n## The range() function\n\nA range is another type of iterable that is commonly used in for loops. Ranges are sequences of integers created using the range() function.\n\nThe syntax of the range function is as follows:\n```python\nrange(<start>, <end>, <step>)\n```\n\nThis gives us all the integers from \"start\" to \"end\" (*excluding* \"end\") in increments of \"step\". Both the \"start\" and \"step\" arguments can be omitted, but \"end\" must be supplied.\n\nLet's work through some examples:\n\n## List comprehensions\n\nIf we want to apply some simple transformation to all the elements in an iterable and store these transformations in a new list, we can use a Python construct called **list comprehensions**.\n\nThe syntax for list comprehensions is as follows:\n```python\n<newList> = [<statement> for i in <existingList> if <condition> ]\n```\nIn the above notation, Python goes through all the elements in \"existingList\" that satisfy \"condition\", inputs each of these elements into \"statement\" (i.e. some Python code) one by one, and collects the results of these statements into a new list called \"newList\".\n\nThat sounds pretty complicated but it really isn't once you look at some examples:\n\nThe if statement is not required:\n","srcMarkdownNoYaml":"\n\n# Lecture Overview\n\n# Conditional Statements (if / elif / else)\n\nConditional statements allow us to tell Python to run certain lines of code (statements) only if some condition is satisfied. The syntax for conditional statements in python is as follows:\n\n```python\nif <condition>:\n    <statement(s)>\nelif <condition>:\n    <statement(s)>\nelse:\n    <statement(s)>\n```\nNote that the \"<>\" symbols should not appear in your code. They just signify places where *you* are expected to input something. \n\nEach conditional statement must have exactly one \"if\" condition, any number of \"elif\" conditions (as long as they are all between \"if\" and \"else\") and zero or one \"else\" statements. Each if/elif/else block is called a **branch** of that conditional statement.\n\nLet's work through some examples to show exactly how these conditional statements function:\n\nIndentation matters: all lines of code under a particular if/else branch must have the same indent (which must be deeper than the indent of the if statement itself):\n\nThe order of the conditions matters: only the statements under the **first** true condition (from the top) will be executed:\n\nAnything that has a truth value (i.e. evaluates to True or False) can be supplied as the condition after an \"if\" or \"elif\" (but not after \"else\"):\n\nFrom the Python official documentation (https://docs.python.org/3/library/stdtypes.html):\n\nHere are most of the built-in objects considered false:\n\n- constants defined to be false: None and False.\n\n- zero of any numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)\n\n- empty sequences and collections: '', (), [], {}, set(), range(0)\n\nCompound conditions (joined by logical operators like \"and\", \"or\") can be supplied on any \"if\" and \"elif\". Just make sure each condition is in its own set of parentheses:\n\n# Iteration ('for' loops)\n\nThe concept of iteration is fundamental to all programming languages. Iteration is one of the key reasons why programming is so powerful: it allows us to do something repeatedly, with only a slight modification each time around. We'll explain what that means using lots of examples below, but first, here is the general syntax of a \"for\" loop - the most widely used method of iteration in Python: \n\n```python\nfor <var> in <iterable>:\n    <statement(s)>\n```\n\nFor example, in the loop below, \\<var\\> is i, \\<iterable\\> is the list \\[1, 'a', [2,3]\\], and \\<statement(s)\\> is the single line of code \"print(i)\"\n\nThe for loop \"iterates over\" (i.e. cycles through the elements of) the list \\[1, 'a', [2,3]\\]. Each time around, it assigns that element the name i, and then it executes the line(s) of code in the \"body\" of the for loop (i.e. \"print(i)\") in our example.\n\nSo the for loop above is equivalent to the following code:\n\nJust like with \"if\" statements, the body of the loop can contain multiple lines of code (statements), as long as they have the same indent:\n\nCan you tell why the following code does not produce the same output?\n\nThe \"iterable\" that we iterate over with the for loop, does not have to be a list. It can be any data structure with elements over which Python knows how to cycle (e.g. a tuple, a dictionary, a string, and many others):\n\nNote that the loop only iterates over the \"keys\" of the dictionary. If we want access to the \"values\" of the dictionary we have to use the \"values()\" attribute for dictionaries:\n\nThis dictionary example shows you that the behavior of the loop depends crucially on the nature of the iterable you supply it (i.e. Python may iterate over objects of different types in different ways). The easiest way to see how Python iterates over objects of a particular type is to just create an example of such a type and then print its elements in a loop.\n\nFor example, if you were curious how Python iterates over a nested list (a list of lists), you can use something like this:\n\n**The \"break\" statement**\n\nThe \"break\" command tells Python to exit the loop regardless of weather it has finished looping through the elements of its iterable:\n\n## The range() function\n\nA range is another type of iterable that is commonly used in for loops. Ranges are sequences of integers created using the range() function.\n\nThe syntax of the range function is as follows:\n```python\nrange(<start>, <end>, <step>)\n```\n\nThis gives us all the integers from \"start\" to \"end\" (*excluding* \"end\") in increments of \"step\". Both the \"start\" and \"step\" arguments can be omitted, but \"end\" must be supplied.\n\nLet's work through some examples:\n\n## List comprehensions\n\nIf we want to apply some simple transformation to all the elements in an iterable and store these transformations in a new list, we can use a Python construct called **list comprehensions**.\n\nThe syntax for list comprehensions is as follows:\n```python\n<newList> = [<statement> for i in <existingList> if <condition> ]\n```\nIn the above notation, Python goes through all the elements in \"existingList\" that satisfy \"condition\", inputs each of these elements into \"statement\" (i.e. some Python code) one by one, and collects the results of these statements into a new list called \"newList\".\n\nThat sounds pretty complicated but it really isn't once you look at some examples:\n\nThe if statement is not required:\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"lecture04_Conditional_Statements_and_Iteration.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"zephyr","page-layout":"full","grid":{"sidebar-width":"400px"},"title":"L04: Conditionals, loops"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}