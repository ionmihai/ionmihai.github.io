{"title":"L05: Functions, packages","markdown":{"yaml":{"title":"L05: Functions, packages"},"headingText":"Lecture Overview","containsRefs":false,"markdown":"\n\n\nIn this lecture we introduce \"functions\" which give us a way to re-use a piece of code without having to type it all out every time we need to use it. We show how to construct functions (\"define\" them) and how to use them (\"call\" them). \n\nWe then introduce \"packages\", which give us a way to bundle multiple functions under a single name. \n\nFinally, we show how functions and packages give us a way to chain together multiple Python commands on a single line of code.\n\n# Functions\n\nFunctions are pieces of code with a name. The general syntax for creating a function is as follow:\n\n```python\ndef <functionName>(<functionArguments>):\n    <statement(s)>\n    return <value>\n```\nDeclared as above, functions take in some data (\\<functionArguments\\>), perform some calculation based on that data (\\<statement(s)\\>), and output the results of that calculation to be used later on in the program (return \\<\\value>).\n\nWe will see below, that one can omit the function arguments, the statements in the body of the function, or the return statement at the end (though not all at once).\n\nHere is a very simple example of a function that calculates the sum of its arguments and outputs (returns) the value of that sum:\n\nNote that the above code only \"**defines**\" what the function \"mysum\" does, but it does not actually \"do\" anything (no calculation is actually performed). To make the function do something, we need to use it in an expression (this is referred to as \"**calling**\" the function):\n\nSome functions have no arguments:\n\nSome functions have no statements in their body:\n\nSome functions have no return statement:\n\nFunctions without a return statements, do actually return something: the Python value \"None\":\n\nWhen a function executes a return statement, it does not execute any remaining code in the body of the function (i.e. it **exits**):\n\n## Positional vs keyword arguments\n\nWhen you call (use) a function, you can provide arguments based on their name (keyword arguments), or based on their position (positional arguments)\n\nUsing positional arguments:\n\nUsing keyword arguments:\n\nThe benefit of using keyword arguments is that you don't have to remember their order in the function definition, and accidentally do something like this:\n\nAs long as you remember the keywords (\"age\" and \"name\" in our example), you don't have to worry about the order in which you supply them to the function call:\n\nThe drawback of keyword arguments is that you have to remember the keywords:\n\n## Required vs optional parameters\n\nRegardless of whether we use positional or keyword arguments, in the examples above, we always had to supply the correct *number* of arguments:\n\nTo get around this issue, we can supply **default values** for some of the parameters **when we define the function**, even if these default values are \"empty\" (using the None value):\n\nIf we don't have to give a meaningful default value to a parameter, we can use the \"None\" value:\n\nThe one rule you need to remember about optional parameters (ones with a default value) is that they need to be specified AFTER all the require parameters:\n\n## Advanced properties of functions (OPTIONAL)\n\n### Side-effects\n\nIn some instances, functions can alter the value of the objects used as their parameters:\n\nIn some instances, functions can NOT alter the value of their arguments:\n\nAs a general rule, functions can modify the values of arguments of mutable type (e.g. list, dict) but not the values of arguments of immutable type (e.g. int, str, tuple). If you are interested in more details, a nice discussion is provided here:\nhttps://realpython.com/defining-your-own-python-function/#argument-passing\n\n### Variable-length argument lists\n\nYou don't have to decide how many arguments your function should take when you define that function. For example, the function below can take in ANY number of arguments and prints them all out:\n\nWe will not be using this functionality in this course but you can read more about it here: https://realpython.com/defining-your-own-python-function/#variable-length-argument-lists\n\n# Packages\n\nPython allows us to use functions defined in a different location. As long as the function we want to use is in a \".py\" file somewhere on your computer, you should be able to \"import\" it in the current file so you can use it.\n\nFor example, in the same folder as these lectures, you should have a file called \"MyPackage.py\" (though you may not see the \".py\"), which contains two functions: mylist(), and myprint(). We can use those functions here, by just importing \"MyPackage\":\n\nNow we can use the functions inside \"MyPackage\" using the dot notation (familiar from when we introduced object attributes):\n\nOften times, we rename a package (right after we import it) to a shorter name (to reduce typing):\n\nWe can also import all the functions inside a package in such a way that we don't have to keep specifying the package name every time we use the function (though this approach is not recommended):\n\n## Packages vs modules vs scripts (OPTIONAL)\n\nSome terminology:\n\nPython **scripts** are \".py\" files that are primarily meant to be run.\n\nPython **modules** are \".py\" files that are primarily meant to be imported.\n\nPython **packages** are collections of Python modules.\n\nSo, technically speaking, the \"MyPackage.py\" file is a module. \n\nYou do not have to remember this terminology for the purpose of this class. We will USE packages that other people have written, but, to keep things simple, we will not write any scripts, modules, or packages of our own: we will execute all our code inside Jupyter Notebooks like this one. \n\nHowever, if you are serious about Python programming beyond the scope of this class, it is very important to understand exactly how packages, modules, and scripts work. A nice discussion can be found here: https://realpython.com/python-modules-packages/\n\n# Chaining commands together\n\nWhenever a function in Python returns a value, we can operate on that value immediately (in the same line of code as the function call).\n\nFor example the following code:\n\nIs equivalent to this:\n\nPython first runs the mylist function, which returns the list [1,2]:\n\nAnd then applies the [-1] slice to that list, running something equivalent to:\n\nWe can also chain multiple function calls together:\n\nThis works because the output of ``mp.mylist(5,13)`` is a list, and lists have an attribute called ``__len__()`` which returns the number of elements of a list. \n\nWe can chain as many function/attribute calls as we want on a single line of code. **Python will execute function/attribute calls from left to right** on any given line of code. So we have to make sure that, whenever we use an attribute, all the code on its left produces output of a type that has the attribute we want to use.\n\nFor example, in the line below:\n\nWe saw that ``mp.mylist(5,13).__len__()`` produces an output of type int (the number 9):\n\nAnd objects of type int, have ``__sizeof__`` as an attribute (which gives us the amount of memory that int is using):\n\nIf ``__sizeof__`` was not in the list above, we could have not applied ``.__sizeof__()`` after ``mp.mylist(5,13).__len__()``\n\nFinally, ``mp.mylist(5,13).__len__().__sizeof__()`` shows us that the dot can be used to separate package names (mp), user-written functions (mylist) as well as built-in attributes (``__len__`` and ``__sizeof__``) \n","srcMarkdownNoYaml":"\n\n# Lecture Overview\n\nIn this lecture we introduce \"functions\" which give us a way to re-use a piece of code without having to type it all out every time we need to use it. We show how to construct functions (\"define\" them) and how to use them (\"call\" them). \n\nWe then introduce \"packages\", which give us a way to bundle multiple functions under a single name. \n\nFinally, we show how functions and packages give us a way to chain together multiple Python commands on a single line of code.\n\n# Functions\n\nFunctions are pieces of code with a name. The general syntax for creating a function is as follow:\n\n```python\ndef <functionName>(<functionArguments>):\n    <statement(s)>\n    return <value>\n```\nDeclared as above, functions take in some data (\\<functionArguments\\>), perform some calculation based on that data (\\<statement(s)\\>), and output the results of that calculation to be used later on in the program (return \\<\\value>).\n\nWe will see below, that one can omit the function arguments, the statements in the body of the function, or the return statement at the end (though not all at once).\n\nHere is a very simple example of a function that calculates the sum of its arguments and outputs (returns) the value of that sum:\n\nNote that the above code only \"**defines**\" what the function \"mysum\" does, but it does not actually \"do\" anything (no calculation is actually performed). To make the function do something, we need to use it in an expression (this is referred to as \"**calling**\" the function):\n\nSome functions have no arguments:\n\nSome functions have no statements in their body:\n\nSome functions have no return statement:\n\nFunctions without a return statements, do actually return something: the Python value \"None\":\n\nWhen a function executes a return statement, it does not execute any remaining code in the body of the function (i.e. it **exits**):\n\n## Positional vs keyword arguments\n\nWhen you call (use) a function, you can provide arguments based on their name (keyword arguments), or based on their position (positional arguments)\n\nUsing positional arguments:\n\nUsing keyword arguments:\n\nThe benefit of using keyword arguments is that you don't have to remember their order in the function definition, and accidentally do something like this:\n\nAs long as you remember the keywords (\"age\" and \"name\" in our example), you don't have to worry about the order in which you supply them to the function call:\n\nThe drawback of keyword arguments is that you have to remember the keywords:\n\n## Required vs optional parameters\n\nRegardless of whether we use positional or keyword arguments, in the examples above, we always had to supply the correct *number* of arguments:\n\nTo get around this issue, we can supply **default values** for some of the parameters **when we define the function**, even if these default values are \"empty\" (using the None value):\n\nIf we don't have to give a meaningful default value to a parameter, we can use the \"None\" value:\n\nThe one rule you need to remember about optional parameters (ones with a default value) is that they need to be specified AFTER all the require parameters:\n\n## Advanced properties of functions (OPTIONAL)\n\n### Side-effects\n\nIn some instances, functions can alter the value of the objects used as their parameters:\n\nIn some instances, functions can NOT alter the value of their arguments:\n\nAs a general rule, functions can modify the values of arguments of mutable type (e.g. list, dict) but not the values of arguments of immutable type (e.g. int, str, tuple). If you are interested in more details, a nice discussion is provided here:\nhttps://realpython.com/defining-your-own-python-function/#argument-passing\n\n### Variable-length argument lists\n\nYou don't have to decide how many arguments your function should take when you define that function. For example, the function below can take in ANY number of arguments and prints them all out:\n\nWe will not be using this functionality in this course but you can read more about it here: https://realpython.com/defining-your-own-python-function/#variable-length-argument-lists\n\n# Packages\n\nPython allows us to use functions defined in a different location. As long as the function we want to use is in a \".py\" file somewhere on your computer, you should be able to \"import\" it in the current file so you can use it.\n\nFor example, in the same folder as these lectures, you should have a file called \"MyPackage.py\" (though you may not see the \".py\"), which contains two functions: mylist(), and myprint(). We can use those functions here, by just importing \"MyPackage\":\n\nNow we can use the functions inside \"MyPackage\" using the dot notation (familiar from when we introduced object attributes):\n\nOften times, we rename a package (right after we import it) to a shorter name (to reduce typing):\n\nWe can also import all the functions inside a package in such a way that we don't have to keep specifying the package name every time we use the function (though this approach is not recommended):\n\n## Packages vs modules vs scripts (OPTIONAL)\n\nSome terminology:\n\nPython **scripts** are \".py\" files that are primarily meant to be run.\n\nPython **modules** are \".py\" files that are primarily meant to be imported.\n\nPython **packages** are collections of Python modules.\n\nSo, technically speaking, the \"MyPackage.py\" file is a module. \n\nYou do not have to remember this terminology for the purpose of this class. We will USE packages that other people have written, but, to keep things simple, we will not write any scripts, modules, or packages of our own: we will execute all our code inside Jupyter Notebooks like this one. \n\nHowever, if you are serious about Python programming beyond the scope of this class, it is very important to understand exactly how packages, modules, and scripts work. A nice discussion can be found here: https://realpython.com/python-modules-packages/\n\n# Chaining commands together\n\nWhenever a function in Python returns a value, we can operate on that value immediately (in the same line of code as the function call).\n\nFor example the following code:\n\nIs equivalent to this:\n\nPython first runs the mylist function, which returns the list [1,2]:\n\nAnd then applies the [-1] slice to that list, running something equivalent to:\n\nWe can also chain multiple function calls together:\n\nThis works because the output of ``mp.mylist(5,13)`` is a list, and lists have an attribute called ``__len__()`` which returns the number of elements of a list. \n\nWe can chain as many function/attribute calls as we want on a single line of code. **Python will execute function/attribute calls from left to right** on any given line of code. So we have to make sure that, whenever we use an attribute, all the code on its left produces output of a type that has the attribute we want to use.\n\nFor example, in the line below:\n\nWe saw that ``mp.mylist(5,13).__len__()`` produces an output of type int (the number 9):\n\nAnd objects of type int, have ``__sizeof__`` as an attribute (which gives us the amount of memory that int is using):\n\nIf ``__sizeof__`` was not in the list above, we could have not applied ``.__sizeof__()`` after ``mp.mylist(5,13).__len__()``\n\nFinally, ``mp.mylist(5,13).__len__().__sizeof__()`` shows us that the dot can be used to separate package names (mp), user-written functions (mylist) as well as built-in attributes (``__len__`` and ``__sizeof__``) \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"lecture05_Functions_and_Packages.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"zephyr","page-layout":"full","grid":{"sidebar-width":"400px"},"title":"L05: Functions, packages"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}