{"title":"L03: Data structures","markdown":{"yaml":{"title":"L03: Data structures"},"headingText":"Lecture overview","containsRefs":false,"markdown":"\n\n\nWe begin this lecture with a discussion of data structures. These are just collections of several pieces of data. Python provides a few different types of data structures, each with different properties (and hence, different use cases). We will talk about only the most commonly used ones in this course: lists, tuples, and dictionaries. Strings are also data structures (they are sequences of single characters) but we already covered them in the previous class. \n\nIn Python, different data structures (or basic data types like int or float) come with different \"attributes\" (pieces of code that compute something using the data in that data structure). These attributes and methods can be accessed using the \"dot\" notation (object, followed by a . followed by the attribute name or method name). We will cover these concepts in the second part of the lecture.\n\n# Lists\n\nLists are sequences of several pieces of data that are mutable (can be changed) and ordered.\n\nLists are created using square brackets, separating its elements (members) with commas:\n\nLists can contain elements of different types:\n\nElements (members) of a list can be accessed using the same slicing techniques we used for strings:\n\nBecause Pyhton starts counting from 0, the above notation usually causes some confusion: \"How come 1:3 gives me the second and third elements? One way to remember this is to think of 1 and 3 as endpoints \"between\" the elements of the list: 1 is an endpoint between the first and second elements, and 3 is between the third and fourth elements. 1:3 asks python for all the elements of the list between those end points (which means the second and third elements). \n\nNote that you can omit one of the endpoints in a slice:\n\nAnd remember that negative positions mean \"starting from the end\":\n\nRemember, lists are ordered. This means that two lists with the same elements but in different order, are not the same:\n\nList are mutable. That means you can change the value of their elements:\n\nCommon operators for lists (+, *, in) work as they do for strings:\n\n# Tuples\n\nTuples are also sequences of several pieces of data. Tuples are also ordered, but they are NOT mutable (i.e. they are immutable: their elements can not be changed). \n\nWe create tuples using parentheses, with elements separated by commas:\n\nEverything we learned for lists can be performed for tuples, except for changing the value of any of its elements:\n\n# Dictionaries (dict)\n\nPython dictionaries are data structures that allow us to collect key-value pairs. This is similar to how a real dictionary is structured: words are \"keys\" and their definitions are \"values\"\n\nWe construct dictionaries using curly brackets, with key-value pairs separated by commas, and each key separated by its value with a colon (:)\n\nIn the example above, the \"keys\" of the dictionary are 'k1', 'k2', and 5 (note that they do not have to be of the same type).\nThe \"values\" of the dictionary are 1, 'abc', and [6,7] (values also do not have to have the same type.\n\nThe main difference between dictionaries and lists is in the way we access their elements. For lists, we use the position of that element in the list. For dictionaries, we use the key of the value we want to retrieve:\n\nThere are no restrictions on what the values in a dictionaries can be, but keys must be unique. If not, the last entry will be the only one recorded:\n\nAdding and entry to a dictionary:\n\nChanging an entry:\n\nRemoving an entry:\n\nNote that if you try to run the cell above TWICE, the second time, it will give you an error, because it tries to delete the entry for key 'b' but it can't find it, since you already deleted it the first time you ran the code.\n\n# Attributes, and the dot notation\n\nObjects of different types (either basic data types like int and float or data structures like lists or dicts) have a number of predefined **attributes**, which allow you to compute something about that object. You may also see these attributes referred to as **methods** (for the most part, the two terms are interchangeable).\n\nWe can list out all the attributes of a particular object using the dir command:\n\nNote that we would get the same answer for any other list (i.e. available attributes are the same for all objects of a give type):\n\nAnd the result is different for different kinds of data types:\n\nEach of these attributes does something else. For example, in the list of dictionary attributes above, 'keys' gives us a list of all the keys of that dictionary. To use the 'keys' attribute, we write the name of that attribute after the name of the dictionary we want to apply it to, separated by a dot:\n\nThere are different rules that you need to follow for each attribute, in terms of what you need to write AFTER the name of the attribute (e.g. putting parentheses after keys in the example above, is mandatory, otherwise you will get an error message). These rules are referred to as the **syntax** of that attribute. \n\nThere is a very lager number of attributes in python and **you are not expected to remember any of the rules associated with those attributes**. There will be some that we will use so often that you will just remember how to use them naturally, but you will not be required to. This is the reason why programmers always have a Google tab open: you will constantly have to search how you're supposed to use a particular attribute.\n\nWe will introduce more attributes as we need them throughout the rest of the semester. This section was just meant to introduce you to the concept and make you familiar with the dot notation. This notation is also used to access subpackages of Python packages. We will talk more about this when we cover packages in more detail later on.\n\n# Python built-in functions\n\nPython has a set of built-in functions that are not specific to any given data type (like the attributes we mentioned above). We have already used several such functions: \"print\", \"type\", \"dir\". A full list of built-in functions, as well as the syntax for all of them can be found here: https://docs.python.org/3/library/functions.html\n\n\nNote that, to use these built-in functions, we do not use the dot notation mentioned above. Instead, we pass the data on which we want to operate as a \"parameter\" to the function (i.e. inside parentheses, after the function name).\n\nFor example, we write:\n\nNot:\n\nWe will talk more about specific built-in functions as we need them later on in the course. If you want to take a look ahead of time, some of the most commonly used ones are: range(), abs(), list(), dict(), len(), round(), sum(), str(), zip().\n","srcMarkdownNoYaml":"\n\n# Lecture overview\n\nWe begin this lecture with a discussion of data structures. These are just collections of several pieces of data. Python provides a few different types of data structures, each with different properties (and hence, different use cases). We will talk about only the most commonly used ones in this course: lists, tuples, and dictionaries. Strings are also data structures (they are sequences of single characters) but we already covered them in the previous class. \n\nIn Python, different data structures (or basic data types like int or float) come with different \"attributes\" (pieces of code that compute something using the data in that data structure). These attributes and methods can be accessed using the \"dot\" notation (object, followed by a . followed by the attribute name or method name). We will cover these concepts in the second part of the lecture.\n\n# Lists\n\nLists are sequences of several pieces of data that are mutable (can be changed) and ordered.\n\nLists are created using square brackets, separating its elements (members) with commas:\n\nLists can contain elements of different types:\n\nElements (members) of a list can be accessed using the same slicing techniques we used for strings:\n\nBecause Pyhton starts counting from 0, the above notation usually causes some confusion: \"How come 1:3 gives me the second and third elements? One way to remember this is to think of 1 and 3 as endpoints \"between\" the elements of the list: 1 is an endpoint between the first and second elements, and 3 is between the third and fourth elements. 1:3 asks python for all the elements of the list between those end points (which means the second and third elements). \n\nNote that you can omit one of the endpoints in a slice:\n\nAnd remember that negative positions mean \"starting from the end\":\n\nRemember, lists are ordered. This means that two lists with the same elements but in different order, are not the same:\n\nList are mutable. That means you can change the value of their elements:\n\nCommon operators for lists (+, *, in) work as they do for strings:\n\n# Tuples\n\nTuples are also sequences of several pieces of data. Tuples are also ordered, but they are NOT mutable (i.e. they are immutable: their elements can not be changed). \n\nWe create tuples using parentheses, with elements separated by commas:\n\nEverything we learned for lists can be performed for tuples, except for changing the value of any of its elements:\n\n# Dictionaries (dict)\n\nPython dictionaries are data structures that allow us to collect key-value pairs. This is similar to how a real dictionary is structured: words are \"keys\" and their definitions are \"values\"\n\nWe construct dictionaries using curly brackets, with key-value pairs separated by commas, and each key separated by its value with a colon (:)\n\nIn the example above, the \"keys\" of the dictionary are 'k1', 'k2', and 5 (note that they do not have to be of the same type).\nThe \"values\" of the dictionary are 1, 'abc', and [6,7] (values also do not have to have the same type.\n\nThe main difference between dictionaries and lists is in the way we access their elements. For lists, we use the position of that element in the list. For dictionaries, we use the key of the value we want to retrieve:\n\nThere are no restrictions on what the values in a dictionaries can be, but keys must be unique. If not, the last entry will be the only one recorded:\n\nAdding and entry to a dictionary:\n\nChanging an entry:\n\nRemoving an entry:\n\nNote that if you try to run the cell above TWICE, the second time, it will give you an error, because it tries to delete the entry for key 'b' but it can't find it, since you already deleted it the first time you ran the code.\n\n# Attributes, and the dot notation\n\nObjects of different types (either basic data types like int and float or data structures like lists or dicts) have a number of predefined **attributes**, which allow you to compute something about that object. You may also see these attributes referred to as **methods** (for the most part, the two terms are interchangeable).\n\nWe can list out all the attributes of a particular object using the dir command:\n\nNote that we would get the same answer for any other list (i.e. available attributes are the same for all objects of a give type):\n\nAnd the result is different for different kinds of data types:\n\nEach of these attributes does something else. For example, in the list of dictionary attributes above, 'keys' gives us a list of all the keys of that dictionary. To use the 'keys' attribute, we write the name of that attribute after the name of the dictionary we want to apply it to, separated by a dot:\n\nThere are different rules that you need to follow for each attribute, in terms of what you need to write AFTER the name of the attribute (e.g. putting parentheses after keys in the example above, is mandatory, otherwise you will get an error message). These rules are referred to as the **syntax** of that attribute. \n\nThere is a very lager number of attributes in python and **you are not expected to remember any of the rules associated with those attributes**. There will be some that we will use so often that you will just remember how to use them naturally, but you will not be required to. This is the reason why programmers always have a Google tab open: you will constantly have to search how you're supposed to use a particular attribute.\n\nWe will introduce more attributes as we need them throughout the rest of the semester. This section was just meant to introduce you to the concept and make you familiar with the dot notation. This notation is also used to access subpackages of Python packages. We will talk more about this when we cover packages in more detail later on.\n\n# Python built-in functions\n\nPython has a set of built-in functions that are not specific to any given data type (like the attributes we mentioned above). We have already used several such functions: \"print\", \"type\", \"dir\". A full list of built-in functions, as well as the syntax for all of them can be found here: https://docs.python.org/3/library/functions.html\n\n\nNote that, to use these built-in functions, we do not use the dot notation mentioned above. Instead, we pass the data on which we want to operate as a \"parameter\" to the function (i.e. inside parentheses, after the function name).\n\nFor example, we write:\n\nNot:\n\nWe will talk more about specific built-in functions as we need them later on in the course. If you want to take a look ahead of time, some of the most commonly used ones are: range(), abs(), list(), dict(), len(), round(), sum(), str(), zip().\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"lecture03_Data_Structures_Dot_Notation.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"zephyr","page-layout":"full","grid":{"sidebar-width":"400px"},"title":"L03: Data structures"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}