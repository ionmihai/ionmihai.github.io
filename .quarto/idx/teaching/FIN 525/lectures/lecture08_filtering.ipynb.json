{"title":"L08: Pandas filtering","markdown":{"yaml":{"title":"L08: Pandas filtering"},"headingText":"Preliminaries","containsRefs":false,"markdown":"\n\n\n# Filtering (subsetting) pandas DataFrames \n\n## The \".loc\" attribute\n\nThe most common way to access a subset of the data in a dataframe is through the \".loc\" attribute. This attribute uses square brackets instead of parentheses and contains two arguments: the first one tells Python which rows you want, and the second one tells it which columns you want, which generally looks like this:\n\n```python\nDataFrame.loc[<which_rows>, <which_columns>]\n```\nwhere, instead of ``DataFrame`` you wouls use the name of the full dataframe you want to subset. Pandas allows for a lot of flexibility as to what you can use instead of ``<which_rows>`` and ``<which_column>`` above. See the examples in the official documentation to get a more complete picture of what is possible with ``.loc[]``: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html\n\nBelow, I cover the most common ways to specify which rows and columns you want:\n\n1. By explicitly specifying the names (labels) of the index and/or column(s)\n2. Using slices (ranges) on the index labels or common labels\n2. Anything that returns a boolean sequence (True will be interpreted as \"I want this row/column\")\n\n### Subsetting with explicit labels\n\n### Subsetting with slices on labels\n\n### Subsetting with boolean arrays\n\n## The \".iloc\" attribute\n\nWorks almost identically to ``.loc()`` with one crucial exception: ``.iloc()`` uses index/column **integer positions** (as opposed to labels like ``.loc()``).\n\nSlicing also works, but this time we have to use index/column numbers, and the right-most end of the range is **not** included:\n\nWe rarely use boolean arrays with ``.iloc()`` so we will not cover it here.\n\n## The \".filter()\" attribute\n\nThe ``.filter()`` attribute comes in handy if we want to subset based on index or column names (labels). In particular, its ``like`` parameter allows us to specify that we want all rows/columns that contain a particular piece of text in their label.\n\nSyntax:\n```python\nDataFrame.filter(items=None, like=None, regex=None, axis=None)\n```\n\nFor example:\n\n## Copies vs \"views\"\n\nLet's make a copy of df that we can safely change for this section:\n\nMany times, we want to store a subset of a dataframe inside a new dataframe. For example:\n\nNow suppose we have to make a change to the larger dataframe ``newdf``. For example:\n\nThis change will be passed to ``sub``, even tough we never created this change explicitly ourselves:\n\nThis happened because, when we created ``sub`` with the command ``sub = newdf.loc[:,'price']``, Pyhton did not actually create an entirely new dataframe. Instead, it just returned something like an address of where in ``newdf`` the ``price`` data can be found. This is called a **view** of the data. \n\nThis is done to preserve memory and speed up the code, but, like we saw above, it can cause some of our dataframes change when we edit other dataframes. \n\nTo avoid this possible problem, I recommend always telling Python to create a copy of the subset of data you want, using the ``.copy()`` attribute. In our example above, ``sub`` should have been created like this: \n\nNow, changes to newdf, like this:\n\nWill not cause sub to change:\n\n# Filtering on a MultiIndex\n\nSo far, the all the dataframes we've seen have had a one-dimensional index (a signle column). Dataframes can have a higher-dimensional index, and when they do, Pandas calls that index a MultiIndex (for a more thorough tutorial on MultiIndex, see https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html)\n\nLet's create an example dataframe with a MultiIndex. Below, we create the MultiIndex using the ``pd.MultiIndex.from_product()`` function, but there are several other ways of creating one (see the link above).\n\nNow, the index has two columns instead of one:\n\nEach entry (row) in the index is a tuple (note the parentheses):\n\nThis means that if we want to use index labels with ``.loc`` to extract some subset of a dataframe, we need to use a tuple when we specify those index labels: \n\nWe can use slices on each dimension of the index, though you should make sure that you sorted your data by the values in the index first (using the ``sort_index()`` function:\n\nI recommend using the ``slice()`` to slide on each dimension of the index. Below, ``slice(None)`` means no condition should be imposed on that dimension of the index:\n\nThough indexing on the first dimension of the index is a lot easier:\n\nHowever, the convenient syntax above does not work for the other dimensions of the index (e.g. ``m.loc[2008:2010]`` will not work).\n","srcMarkdownNoYaml":"\n\n# Preliminaries\n\n# Filtering (subsetting) pandas DataFrames \n\n## The \".loc\" attribute\n\nThe most common way to access a subset of the data in a dataframe is through the \".loc\" attribute. This attribute uses square brackets instead of parentheses and contains two arguments: the first one tells Python which rows you want, and the second one tells it which columns you want, which generally looks like this:\n\n```python\nDataFrame.loc[<which_rows>, <which_columns>]\n```\nwhere, instead of ``DataFrame`` you wouls use the name of the full dataframe you want to subset. Pandas allows for a lot of flexibility as to what you can use instead of ``<which_rows>`` and ``<which_column>`` above. See the examples in the official documentation to get a more complete picture of what is possible with ``.loc[]``: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html\n\nBelow, I cover the most common ways to specify which rows and columns you want:\n\n1. By explicitly specifying the names (labels) of the index and/or column(s)\n2. Using slices (ranges) on the index labels or common labels\n2. Anything that returns a boolean sequence (True will be interpreted as \"I want this row/column\")\n\n### Subsetting with explicit labels\n\n### Subsetting with slices on labels\n\n### Subsetting with boolean arrays\n\n## The \".iloc\" attribute\n\nWorks almost identically to ``.loc()`` with one crucial exception: ``.iloc()`` uses index/column **integer positions** (as opposed to labels like ``.loc()``).\n\nSlicing also works, but this time we have to use index/column numbers, and the right-most end of the range is **not** included:\n\nWe rarely use boolean arrays with ``.iloc()`` so we will not cover it here.\n\n## The \".filter()\" attribute\n\nThe ``.filter()`` attribute comes in handy if we want to subset based on index or column names (labels). In particular, its ``like`` parameter allows us to specify that we want all rows/columns that contain a particular piece of text in their label.\n\nSyntax:\n```python\nDataFrame.filter(items=None, like=None, regex=None, axis=None)\n```\n\nFor example:\n\n## Copies vs \"views\"\n\nLet's make a copy of df that we can safely change for this section:\n\nMany times, we want to store a subset of a dataframe inside a new dataframe. For example:\n\nNow suppose we have to make a change to the larger dataframe ``newdf``. For example:\n\nThis change will be passed to ``sub``, even tough we never created this change explicitly ourselves:\n\nThis happened because, when we created ``sub`` with the command ``sub = newdf.loc[:,'price']``, Pyhton did not actually create an entirely new dataframe. Instead, it just returned something like an address of where in ``newdf`` the ``price`` data can be found. This is called a **view** of the data. \n\nThis is done to preserve memory and speed up the code, but, like we saw above, it can cause some of our dataframes change when we edit other dataframes. \n\nTo avoid this possible problem, I recommend always telling Python to create a copy of the subset of data you want, using the ``.copy()`` attribute. In our example above, ``sub`` should have been created like this: \n\nNow, changes to newdf, like this:\n\nWill not cause sub to change:\n\n# Filtering on a MultiIndex\n\nSo far, the all the dataframes we've seen have had a one-dimensional index (a signle column). Dataframes can have a higher-dimensional index, and when they do, Pandas calls that index a MultiIndex (for a more thorough tutorial on MultiIndex, see https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html)\n\nLet's create an example dataframe with a MultiIndex. Below, we create the MultiIndex using the ``pd.MultiIndex.from_product()`` function, but there are several other ways of creating one (see the link above).\n\nNow, the index has two columns instead of one:\n\nEach entry (row) in the index is a tuple (note the parentheses):\n\nThis means that if we want to use index labels with ``.loc`` to extract some subset of a dataframe, we need to use a tuple when we specify those index labels: \n\nWe can use slices on each dimension of the index, though you should make sure that you sorted your data by the values in the index first (using the ``sort_index()`` function:\n\nI recommend using the ``slice()`` to slide on each dimension of the index. Below, ``slice(None)`` means no condition should be imposed on that dimension of the index:\n\nThough indexing on the first dimension of the index is a lot easier:\n\nHowever, the convenient syntax above does not work for the other dimensions of the index (e.g. ``m.loc[2008:2010]`` will not work).\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"lecture08_filtering.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"zephyr","page-layout":"full","grid":{"sidebar-width":"400px"},"title":"L08: Pandas filtering"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}