{"title":"L13: Conditional stats, outliers","markdown":{"yaml":{"title":"L13: Conditional stats, outliers"},"headingText":"Lecture overview","containsRefs":false,"markdown":"\n\n\nIn this lecture we introduce a set of Pandas functions that are very useful in describing subsamples of your data (this is often called \"subsample analysis\"). Looking at subsamples of your data individually is important because patterns that show up in your overall dataset may look quite different if you limit yourself to a subset of the dataset. This is exemplified in Simpson's Paradox: https://en.wikipedia.org/wiki/Simpson%27s_paradox.\n\nWe finish the lecture with a discussion of the impact of outliers on your descriptive statistics, and a method of mitigating that impact called \"windsorization\".\n\n# Preliminaries\n\nWe'll use data on the Fama-French 5-industry portfolio returns for this lecture:\n\nExtract equal-weighted *annual* industry returns, and turn them to decimal (they are in percentage points):\n\nLet's take a look at the data:\n\nCalculate cumulative products of gross returns (i.e. compound returns over time) and plot them:\n\nStack industry returns on top of each other for the purpose of this class:\n\nAnd bring date and industry names as data inside the dataframe:\n\n**Challenge:**\n\nDo the same for value-weighted annual returns (i.e. create a \"vw_long\" dataframe, using the same steps we used for \"ew_long\":\n\nMerge the EW returns and VW returns into a single dataframe called \"ireturns\":\n\n# Grouping your data: the ``.groupby()`` function\n\nThe ``.groupby()`` function can be used to tell Python that you want to split your data into groups. The parameters of the ``.groupby()`` function tell Python *how* those groups should be created. The purpose is usually to apply some function (e.g. the \".mean()\" function) to each of these groups separately.\n\nAbbreviated syntax:\n```python\nDataFrame.groupby(by=None, axis=0, level=None, as_index=True, sort=True, dropna=True)\n```\n\nThe most important parameter is ``by``. This is where you tell Python which column (or index) in your DataFrame contains the information based on which you want to group your data. Python will split your DataFrame into \"mini\" dataframes, one for each unique value of the variable(s) you supplied to the ``by`` parameter.\n\nFor example, the line below splits ``ireturns`` into 5 different dataframes, one for each unique entry found in the \"Industry\" column, and then applies the ``.mean()`` function for each of these 5 dataframes separately. Finally, these subsample means are all collected into a new dataframe ``ind_means``: \n\nIf you don't want the ``by`` variable (i.e. \"Industry\" in the example above) to be the index of the resulting dataframe:\n\nAnother example, with a different ``by`` variable and a different function applied to each group (i.e. median instead of mean):\n\nYou can group by more than one variable:\n\nThe example above did not really change the ``ireturns`` dataframe, since each \"Date\" x \"Industry\" pair has a single entry for both \"ewret\" and \"vwret\". Since the mean of a single number is the number itself, the ``twodim`` dataframe will be identical to ``ireturns``. Note that this is not necessarily the case if we used a different function instead of ``.mean()``, for example ``.count()``:\n\nYou can specify which variable(s) you want to apply the function to, in brackets, right before the function name (if you leave this out (like above), the function will be applied to all the columns in the dataframe):\n\n# The ``.apply()`` and ``.transform()`` methods\n\nThe ``.apply()`` and ``.transform()``  methods do similar things: they can be used to tell Python to apply a given function to some data from a dataframe. As the examples above show, there are many Pandas functions, like ``.mean()`` and ``.median()`` that can do this without the help of ``.apply()`` or ``.transform()`` (we just have to add the names of these functions after the ``.groupby()`` statement, just like we did above). But what if the function we want to apply is not a built-in Pandas function that can be applied with a dot after the name of a dataframe? This is where ``.apply()`` and ``.transform()`` come in handy. These methods are especially useful when we want to apply a particular function, separately, to each group we created with a ``.groupby`` statement. \n\nHere is their syntax:\n\nSyntax for ``.transform()``:\n```python\nDataFrame.transform(func, axis=0, *args, **kwargs)\n```\nSyntax for ``.apply()``:\n```python\nDataFrame.apply(func, axis=0, raw=False, result_type=None, args=(), **kwargs)\n```\n\nThe most important argument is ``func`` which is where we tell Python which function we want to apply to the data. \n\nThe main difference between ``.transform()`` and ``.apply()`` is that ``.transform()`` returns a sequence of the same length as the dataframe to which it is applied, while ``.apply()`` returns a DataFrame or Series of the same size as the number of groups to which it is applied.\n\nWe usually add the results of ``.transform()`` as a new column to the same dataframe:\n\nNote, also, that with ``.transform()``, you can pass the name of the function you want as a **string** to the ``func`` argument, whereas with ``.apply()`` you can not:\n\nWhereas the line below will not work. You have to specify which package the \"median\" function belongs to (which is why we used ``.apply(np.median)`` above):\n\nWe are not restricted to applying functions that come with a package that we have installed. We can also use a function that we created ourselves.\n\nFor example, below, we create a function that can take in a Series or a DataFrame of returns, and compounds them:\n\nNow we can apply that function to the returns of each industry:\n\nLet's see if it worked:\n\n# Winsorizing outliers \n\n\"Winsorizing\" a variable means replacing its most extreme values with less extreme values. For example, winsorizing a variable \"at the 5 and 95 percentiles\", means that the values of that variable that are smaller than the 5th percentile will be made equal to the 5th percentile and the values that are larger than the 95th percentile will be made equal to the 95th percentile.\n\nYou can pick other values for the percentiles at which you want to winsorize but (1,99) and (5, 95) are by far the most common ones.\n\nTo winsorize a variable, in a Pandas dataframe, we use the ``.clip()`` function as below. This also requires us to use the ``.quantile()`` function to calculate the 5th and 95th percentiles. First, let's sort the returns so we can easily see its most extreme values (top and bottom):\n\nLet's calculate the 5th and 95th percentiles:\n\nAnd now let's create a version of ``ewret`` that is winsorized at the 5 and 95 percentiles:\n\nLet's see if it worked:\n","srcMarkdownNoYaml":"\n\n# Lecture overview\n\nIn this lecture we introduce a set of Pandas functions that are very useful in describing subsamples of your data (this is often called \"subsample analysis\"). Looking at subsamples of your data individually is important because patterns that show up in your overall dataset may look quite different if you limit yourself to a subset of the dataset. This is exemplified in Simpson's Paradox: https://en.wikipedia.org/wiki/Simpson%27s_paradox.\n\nWe finish the lecture with a discussion of the impact of outliers on your descriptive statistics, and a method of mitigating that impact called \"windsorization\".\n\n# Preliminaries\n\nWe'll use data on the Fama-French 5-industry portfolio returns for this lecture:\n\nExtract equal-weighted *annual* industry returns, and turn them to decimal (they are in percentage points):\n\nLet's take a look at the data:\n\nCalculate cumulative products of gross returns (i.e. compound returns over time) and plot them:\n\nStack industry returns on top of each other for the purpose of this class:\n\nAnd bring date and industry names as data inside the dataframe:\n\n**Challenge:**\n\nDo the same for value-weighted annual returns (i.e. create a \"vw_long\" dataframe, using the same steps we used for \"ew_long\":\n\nMerge the EW returns and VW returns into a single dataframe called \"ireturns\":\n\n# Grouping your data: the ``.groupby()`` function\n\nThe ``.groupby()`` function can be used to tell Python that you want to split your data into groups. The parameters of the ``.groupby()`` function tell Python *how* those groups should be created. The purpose is usually to apply some function (e.g. the \".mean()\" function) to each of these groups separately.\n\nAbbreviated syntax:\n```python\nDataFrame.groupby(by=None, axis=0, level=None, as_index=True, sort=True, dropna=True)\n```\n\nThe most important parameter is ``by``. This is where you tell Python which column (or index) in your DataFrame contains the information based on which you want to group your data. Python will split your DataFrame into \"mini\" dataframes, one for each unique value of the variable(s) you supplied to the ``by`` parameter.\n\nFor example, the line below splits ``ireturns`` into 5 different dataframes, one for each unique entry found in the \"Industry\" column, and then applies the ``.mean()`` function for each of these 5 dataframes separately. Finally, these subsample means are all collected into a new dataframe ``ind_means``: \n\nIf you don't want the ``by`` variable (i.e. \"Industry\" in the example above) to be the index of the resulting dataframe:\n\nAnother example, with a different ``by`` variable and a different function applied to each group (i.e. median instead of mean):\n\nYou can group by more than one variable:\n\nThe example above did not really change the ``ireturns`` dataframe, since each \"Date\" x \"Industry\" pair has a single entry for both \"ewret\" and \"vwret\". Since the mean of a single number is the number itself, the ``twodim`` dataframe will be identical to ``ireturns``. Note that this is not necessarily the case if we used a different function instead of ``.mean()``, for example ``.count()``:\n\nYou can specify which variable(s) you want to apply the function to, in brackets, right before the function name (if you leave this out (like above), the function will be applied to all the columns in the dataframe):\n\n# The ``.apply()`` and ``.transform()`` methods\n\nThe ``.apply()`` and ``.transform()``  methods do similar things: they can be used to tell Python to apply a given function to some data from a dataframe. As the examples above show, there are many Pandas functions, like ``.mean()`` and ``.median()`` that can do this without the help of ``.apply()`` or ``.transform()`` (we just have to add the names of these functions after the ``.groupby()`` statement, just like we did above). But what if the function we want to apply is not a built-in Pandas function that can be applied with a dot after the name of a dataframe? This is where ``.apply()`` and ``.transform()`` come in handy. These methods are especially useful when we want to apply a particular function, separately, to each group we created with a ``.groupby`` statement. \n\nHere is their syntax:\n\nSyntax for ``.transform()``:\n```python\nDataFrame.transform(func, axis=0, *args, **kwargs)\n```\nSyntax for ``.apply()``:\n```python\nDataFrame.apply(func, axis=0, raw=False, result_type=None, args=(), **kwargs)\n```\n\nThe most important argument is ``func`` which is where we tell Python which function we want to apply to the data. \n\nThe main difference between ``.transform()`` and ``.apply()`` is that ``.transform()`` returns a sequence of the same length as the dataframe to which it is applied, while ``.apply()`` returns a DataFrame or Series of the same size as the number of groups to which it is applied.\n\nWe usually add the results of ``.transform()`` as a new column to the same dataframe:\n\nNote, also, that with ``.transform()``, you can pass the name of the function you want as a **string** to the ``func`` argument, whereas with ``.apply()`` you can not:\n\nWhereas the line below will not work. You have to specify which package the \"median\" function belongs to (which is why we used ``.apply(np.median)`` above):\n\nWe are not restricted to applying functions that come with a package that we have installed. We can also use a function that we created ourselves.\n\nFor example, below, we create a function that can take in a Series or a DataFrame of returns, and compounds them:\n\nNow we can apply that function to the returns of each industry:\n\nLet's see if it worked:\n\n# Winsorizing outliers \n\n\"Winsorizing\" a variable means replacing its most extreme values with less extreme values. For example, winsorizing a variable \"at the 5 and 95 percentiles\", means that the values of that variable that are smaller than the 5th percentile will be made equal to the 5th percentile and the values that are larger than the 95th percentile will be made equal to the 95th percentile.\n\nYou can pick other values for the percentiles at which you want to winsorize but (1,99) and (5, 95) are by far the most common ones.\n\nTo winsorize a variable, in a Pandas dataframe, we use the ``.clip()`` function as below. This also requires us to use the ``.quantile()`` function to calculate the 5th and 95th percentiles. First, let's sort the returns so we can easily see its most extreme values (top and bottom):\n\nLet's calculate the 5th and 95th percentiles:\n\nAnd now let's create a version of ``ewret`` that is winsorized at the 5 and 95 percentiles:\n\nLet's see if it worked:\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"lecture13_wins_groupby_apply_transform.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"zephyr","page-layout":"full","grid":{"sidebar-width":"400px"},"title":"L13: Conditional stats, outliers"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}